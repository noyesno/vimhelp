<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>VIM: change</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css"/>
</head>
<body>
<h2>CHANGE</h2>
<pre>
<b class="vimtag">*<a name="change.txt">change.txt</a>*</b>    For Vim version 8.2.  Last change: 2020 Feb 09


		  VIM REFERENCE MANUAL    by Bram Moolenaar


This file describes commands that delete or change text.  In this context,
changing text means deleting the text and replacing it with other text using
one command.  You can undo all of these commands.  You can repeat the non-Ex
commands with the "." command.

1. Deleting text		|<a href="change.html#deleting">deleting</a>|
2. Delete and insert		|<a href="change.html#delete-insert">delete-insert</a>|
3. Simple changes		|<a href="change.html#simple-change">simple-change</a>|		<b class="vimtag">*<a name="changing">changing</a>*</b>
4. Complex changes		|<a href="change.html#complex-change">complex-change</a>|
   4.1 Filter commands		   |<a href="change.html#filter">filter</a>|
   4.2 Substitute		   |<a href="change.html#:substitute">:substitute</a>|
   4.3 Search and replace	   |<a href="change.html#search-replace">search-replace</a>|
   4.4 Changing tabs		   |<a href="change.html#change-tabs">change-tabs</a>|
5. Copying and moving text	|<a href="change.html#copy-move">copy-move</a>|
6. Formatting text		|<a href="change.html#formatting">formatting</a>|
7. Sorting text			|<a href="change.html#sorting">sorting</a>|

For inserting text see |<a href="insert.html#insert.txt">insert</a>|.

</pre><hr/><pre>1. Deleting text					<b class="vimtag">*<a name="deleting">deleting</a>*</b> <b class="vimtag">*<a name="E470">E470</a>*</b>

["x]<code class="special">&lt;Del&gt;</code>	or					<b class="vimtag">*<a name="%3CDel%3E">&lt;Del&gt;</a>*</b> <b class="vimtag">*<a name="x">x</a>*</b> <b class="vimtag">*<a name="dl">dl</a>*</b>
["x]x			Delete <code class="special">[count]</code> characters under and after the cursor
			[into register x] (not |<a href="motion.html#linewise">linewise</a>|).  Does the same as
			"dl".
			The <code class="special">&lt;Del&gt;</code> key does not take a <code class="special">[count]</code>.  Instead, it
			deletes the last character of the count.
			See |<a href="options.html#:fixdel">:fixdel</a>| if the <code class="special">&lt;Del&gt;</code> key does not do what you
			want.  See |<a href="options.html#'whichwrap'">'whichwrap'</a>| for deleting a line break
			(join lines).

							<b class="vimtag">*<a name="X">X</a>*</b> <b class="vimtag">*<a name="dh">dh</a>*</b>
["x]X			Delete <code class="special">[count]</code> characters before the cursor [into
			register x] (not |<a href="motion.html#linewise">linewise</a>|).  Does the same as "dh".
			Also see |<a href="options.html#'whichwrap'">'whichwrap'</a>|.

							<b class="vimtag">*<a name="d">d</a>*</b>
["x]d<code class="special">{motion}</code>		Delete text that <code class="special">{motion}</code> moves over [into register
			x].  See below for exceptions.

							<b class="vimtag">*<a name="dd">dd</a>*</b>
["x]dd			Delete <code class="special">[count]</code> lines [into register x] |<a href="motion.html#linewise">linewise</a>|.

							<b class="vimtag">*<a name="D">D</a>*</b>
["x]D			Delete the characters under the cursor until the end
			of the line and <code class="special">[count]</code>-1 more lines [into register
			x]; synonym for "d$".
			(not |<a href="motion.html#linewise">linewise</a>|)
			When the '#' flag is in 'cpoptions' the count is
			ignored.

<code class="special">{Visual}</code>["x]x	or					<b class="vimtag">*<a name="v_x">v_x</a>*</b> <b class="vimtag">*<a name="v_d">v_d</a>*</b> <b class="vimtag">*<a name="v_%3CDel%3E">v_&lt;Del&gt;</a>*</b>
<code class="special">{Visual}</code>["x]d   or
<code class="special">{Visual}</code>["x]<code class="special">&lt;Del&gt;</code>	Delete the highlighted text [into register x] (for
			<code class="special">{Visual}</code> see |<a href="visual.html#Visual-mode">Visual-mode</a>|).

<code class="special">{Visual}</code>["x]<code class="keystroke">CTRL-H</code>   or					<b class="vimtag">*<a name="v_CTRL-H">v_CTRL-H</a>*</b> <b class="vimtag">*<a name="v_%3CBS%3E">v_&lt;BS&gt;</a>*</b>
<code class="special">{Visual}</code>["x]<code class="special">&lt;BS&gt;</code>	When in Select mode: Delete the highlighted text [into
			register x].

<code class="special">{Visual}</code>["x]X	or					<b class="vimtag">*<a name="v_X">v_X</a>*</b> <b class="vimtag">*<a name="v_D">v_D</a>*</b> <b class="vimtag">*<a name="v_b_D">v_b_D</a>*</b>
<code class="special">{Visual}</code>["x]D		Delete the highlighted lines [into register x] (for
			<code class="special">{Visual}</code> see |<a href="visual.html#Visual-mode">Visual-mode</a>|).  In Visual block mode,
			"D" deletes the highlighted text plus all text until
			the end of the line.

					<b class="vimtag">*<a name=":d">:d</a>*</b> <b class="vimtag">*<a name=":de">:de</a>*</b> <b class="vimtag">*<a name=":del">:del</a>*</b> <b class="vimtag">*<a name=":delete">:delete</a>*</b> <b class="vimtag">*<a name=":dl">:dl</a>*</b> <b class="vimtag">*<a name=":dp">:dp</a>*</b>
:<code class="special">[range]</code>d[elete] [x]	Delete <code class="special">[range]</code> lines (default: current line) [into
			register x].
			<code class="note">Note</code> these weird abbreviations:
			   :dl		delete and list
			   :dell	idem
			   :delel	idem
			   :deletl	idem
			   :deletel	idem
			   :dp		delete and print
			   :dep		idem
			   :delp	idem
			   :delep	idem
			   :deletp	idem
			   :deletep	idem

:<code class="special">[range]</code>d[elete] [x] <code class="special">{count}</code>
			Delete <code class="special">{count}</code> lines, starting with <code class="special">[range]</code>
			(default: current line |<a href="cmdline.html#cmdline-ranges">cmdline-ranges</a>|) [into
			register x].

These commands delete text.  You can repeat them with the `.` command
(except `:d`) and undo them.  Use Visual mode to delete blocks of text.  See
|<a href="change.html#registers">registers</a>| for an explanation of registers.

An exception for the d<code class="special">{motion}</code> command: If the motion is not linewise, the
start and end of the motion are not in the same line, and there are only
blanks before the start and there are no non-blanks after the end of the
motion, the delete becomes linewise.  This means that the delete also removes
the line of blanks that you might expect to remain. Use the |<a href="motion.html#o_v">o_v</a>| operator to
force the motion to be characterwise.

Trying to delete an empty region of text (e.g., "d0" in the first column)
is an error when 'cpoptions' includes the 'E' flag.

							<b class="vimtag">*<a name="J">J</a>*</b>
J			Join <code class="special">[count]</code> lines, with a minimum of two lines.
			Remove the indent and insert up to two spaces (see
			below).  Fails when on the last line of the buffer.
			If <code class="special">[count]</code> is too big it is reduced to the number of
			lines available.

							<b class="vimtag">*<a name="v_J">v_J</a>*</b>
<code class="special">{Visual}</code>J		Join the highlighted lines, with a minimum of two
			lines.  Remove the indent and insert up to two spaces
			(see below).

							<b class="vimtag">*<a name="gJ">gJ</a>*</b>
gJ			Join <code class="special">[count]</code> lines, with a minimum of two lines.
			Don't insert or remove any spaces.

							<b class="vimtag">*<a name="v_gJ">v_gJ</a>*</b>
<code class="special">{Visual}</code>gJ		Join the highlighted lines, with a minimum of two
			lines.  Don't insert or remove any spaces.

							<b class="vimtag">*<a name=":j">:j</a>*</b> <b class="vimtag">*<a name=":join">:join</a>*</b>
:<code class="special">[range]</code>j[oin][!] [flags]
			Join <code class="special">[range]</code> lines.  Same as "J", except with [!]
			the join does not insert or delete any spaces.
			If a <code class="special">[range]</code> has equal start and end values, this
			command does nothing.  The default behavior is to
			join the current line with the line below it.
			See |<a href="cmdline.html#ex-flags">ex-flags</a>| for [flags].

:<code class="special">[range]</code>j[oin][!] <code class="special">{count}</code> [flags]
			Join <code class="special">{count}</code> lines, starting with <code class="special">[range]</code> (default:
			current line |<a href="cmdline.html#cmdline-ranges">cmdline-ranges</a>|).  Same as "J", except
			with [!] the join does not insert or delete any
			spaces.
			See |<a href="cmdline.html#ex-flags">ex-flags</a>| for [flags].

These commands delete the <code class="special">&lt;EOL&gt;</code> between lines.  This has the effect of joining
multiple lines into one line.  You can repeat these commands (except `:j`) and
undo them.

These commands, except "gJ", insert one space in place of the <code class="special">&lt;EOL&gt;</code> unless
there is trailing white space or the next line starts with a ')'.  These
commands, except "gJ", delete any leading white space on the next line.  If
the 'joinspaces' option is on, these commands insert two spaces after a '.',
'!' or '?' (but if 'cpoptions' includes the 'j' flag, they insert two spaces
only after a '.').
The 'B' and 'M' flags in 'formatoptions' change the behavior for inserting
spaces before and after a multi-byte character |<a href="change.html#fo-table">fo-table</a>|.

The '[ mark is set at the end of the first line that was joined, '] at the end
of the resulting line.


</pre><hr/><pre>2. Delete and insert				<b class="vimtag">*<a name="delete-insert">delete-insert</a>*</b> <b class="vimtag">*<a name="replacing">replacing</a>*</b>

							<b class="vimtag">*<a name="R">R</a>*</b>
R			Enter Replace mode: Each character you type replaces
			an existing character, starting with the character
			under the cursor.  Repeat the entered text <code class="special">[count]</code>-1
			times.  See |<a href="insert.html#Replace-mode">Replace-mode</a>| for more details.

							<b class="vimtag">*<a name="gR">gR</a>*</b>
gR			Enter Virtual Replace mode: Each character you type
			replaces existing characters in screen space.  So a
			<code class="special">&lt;Tab&gt;</code> may replace several characters at once.
			Repeat the entered text <code class="special">[count]</code>-1 times.  See
			|<a href="insert.html#Virtual-Replace-mode">Virtual-Replace-mode</a>| for more details.

							<b class="vimtag">*<a name="c">c</a>*</b>
["x]c<code class="special">{motion}</code>		Delete <code class="special">{motion}</code> text [into register x] and start
			insert.  When  'cpoptions' includes the 'E' flag and
			there is no text to delete (e.g., with "cTx" when the
			cursor is just after an 'x'), an error occurs and
			insert mode does not start (this is Vi compatible).
			When  'cpoptions' does not include the 'E' flag, the
			"c" command always starts insert mode, even if there
			is no text to delete.

							<b class="vimtag">*<a name="cc">cc</a>*</b>
["x]cc			Delete <code class="special">[count]</code> lines [into register x] and start
			insert |<a href="motion.html#linewise">linewise</a>|.  If 'autoindent' is on, preserve
			the indent of the first line.

							<b class="vimtag">*<a name="C">C</a>*</b>
["x]C			Delete from the cursor position to the end of the
			line and <code class="special">[count]</code>-1 more lines [into register x], and
			start insert.  Synonym for c$ (not |<a href="motion.html#linewise">linewise</a>|).

							<b class="vimtag">*<a name="s">s</a>*</b>
["x]s			Delete <code class="special">[count]</code> characters [into register x] and start
			insert (s stands for Substitute).  Synonym for "cl"
			(not |<a href="motion.html#linewise">linewise</a>|).

							<b class="vimtag">*<a name="S">S</a>*</b>
["x]S			Delete <code class="special">[count]</code> lines [into register x] and start
			insert.  Synonym for "cc" |<a href="motion.html#linewise">linewise</a>|.

<code class="special">{Visual}</code>["x]c	or					<b class="vimtag">*<a name="v_c">v_c</a>*</b> <b class="vimtag">*<a name="v_s">v_s</a>*</b>
<code class="special">{Visual}</code>["x]s		Delete the highlighted text [into register x] and
			start insert (for <code class="special">{Visual}</code> see |<a href="visual.html#Visual-mode">Visual-mode</a>|).

							<b class="vimtag">*<a name="v_r">v_r</a>*</b>
<code class="special">{Visual}</code>["x]r<code class="special">{char}</code>	Replace all selected characters by <code class="special">{char}</code>.

							<b class="vimtag">*<a name="v_C">v_C</a>*</b>
<code class="special">{Visual}</code>["x]C		Delete the highlighted lines [into register x] and
			start insert.  In Visual block mode it works
			differently |<a href="visual.html#v_b_C">v_b_C</a>|.
							<b class="vimtag">*<a name="v_S">v_S</a>*</b>
<code class="special">{Visual}</code>["x]S		Delete the highlighted lines [into register x] and
			start insert (for <code class="special">{Visual}</code> see |<a href="visual.html#Visual-mode">Visual-mode</a>|).
							<b class="vimtag">*<a name="v_R">v_R</a>*</b>
<code class="special">{Visual}</code>["x]R		Currently just like <code class="special">{Visual}</code>["x]S.  In a next version
			it might work differently.

<code class="note">Note</code>s:
- You can end Insert and Replace mode with <code class="special">&lt;Esc&gt;</code>.
- See the section "Insert and Replace mode" |<a href="insert.html#mode-ins-repl">mode-ins-repl</a>| for the other
  special characters in these modes.
- The effect of <code class="special">[count]</code> takes place after Vim exits Insert or Replace mode.
- When the 'cpoptions' option contains '$' and the change is within one line,
  Vim continues to show the text to be deleted and puts a '$' at the last
  deleted character.

See |<a href="change.html#registers">registers</a>| for an explanation of registers.

Replace mode is just like Insert mode, except that every character you enter
deletes one character.  If you reach the end of a line, Vim appends any
further characters (just like Insert mode).  In Replace mode, the backspace
key restores the original text (if there was any).  (See section "Insert and
Replace mode" |<a href="insert.html#mode-ins-repl">mode-ins-repl</a>|).

						<b class="vimtag">*<a name="cw">cw</a>*</b> <b class="vimtag">*<a name="cW">cW</a>*</b>
Special case: When the cursor is in a word, "cw" and "cW" do not include the
white space after a word, they only change up to the end of the word.  This is
because Vim interprets "cw" as change-word, and a word does not include the
following white space.
{Vi: "cw" when on a blank followed by other blanks changes only the first
blank; this is probably a bug, because "dw" deletes all the blanks; use the
'w' flag in 'cpoptions' to make it work like Vi anyway}

If you prefer "cw" to include the space after a word, use this mapping:
<code class="example">	:map cw dwi</code>
Or use "caw" (see |<a href="motion.html#aw">aw</a>|).

							<b class="vimtag">*<a name=":c">:c</a>*</b> <b class="vimtag">*<a name=":ch">:ch</a>*</b> <b class="vimtag">*<a name=":change">:change</a>*</b>
:<code class="special">{range}</code>c[hange][!]	Replace lines of text with some different text.
			Type a line containing only "." to stop replacing.
			Without <code class="special">{range}</code>, this command changes only the current
			line.
			Adding [!] toggles 'autoindent' for the time this
			command is executed.

</pre><hr/><pre>3. Simple changes					<b class="vimtag">*<a name="simple-change">simple-change</a>*</b>

							<b class="vimtag">*<a name="r">r</a>*</b>
r<code class="special">{char}</code>			Replace the character under the cursor with <code class="special">{char}</code>.
			If <code class="special">{char}</code> is a <code class="special">&lt;CR&gt;</code> or <code class="special">&lt;NL&gt;</code>, a line break replaces the
			character.  To replace with a real <code class="special">&lt;CR&gt;</code>, use <code class="keystroke">CTRL-V</code>
			<code class="special">&lt;CR&gt;</code>.  <code class="keystroke">CTRL-V</code> <code class="special">&lt;NL&gt;</code> replaces with a <code class="special">&lt;Nul&gt;</code>.

			If <code class="special">{char}</code> is <code class="keystroke">CTRL-E</code> or <code class="keystroke">CTRL-Y</code> the character from the
			line below or above is used, just like with |<a href="insert.html#i_CTRL-E">i_CTRL-E</a>|
			and |<a href="insert.html#i_CTRL-Y">i_CTRL-Y</a>|.  This also works with a count, thus
			`10r<code class="special">&lt;C-E&gt;</code>` copies 10 characters from the line below.

			If you give a <code class="special">[count]</code>, Vim replaces <code class="special">[count]</code> characters
			with <code class="special">[count]</code> <code class="special">{char}</code>s.  When <code class="special">{char}</code> is a <code class="special">&lt;CR&gt;</code> or <code class="special">&lt;NL&gt;</code>,
			however, Vim inserts only one <code class="special">&lt;CR&gt;</code>: "5r<code class="special">&lt;CR&gt;</code>" replaces
			five characters with a single line break.
			When <code class="special">{char}</code> is a <code class="special">&lt;CR&gt;</code> or <code class="special">&lt;NL&gt;</code>, Vim performs
			autoindenting.  This works just like deleting the
			characters that are replaced and then doing
			"i<code class="special">&lt;CR&gt;</code><code class="special">&lt;Esc&gt;</code>".
			<code class="special">{char}</code> can be entered as a digraph |<a href="change.html#digraph-arg">digraph-arg</a>|.
			|<a href="map.html#:lmap">:lmap</a>| mappings apply to <code class="special">{char}</code>.  The CTRL-^ command
			in Insert mode can be used to switch this on/off
			|<a href="insert.html#i_CTRL-^">i_CTRL-^</a>|.  See |<a href="mbyte.html#utf-8-char-arg">utf-8-char-arg</a>| about using
			composing characters when 'encoding' is Unicode.

							<b class="vimtag">*<a name="gr">gr</a>*</b>
gr<code class="special">{char}</code>		Replace the virtual characters under the cursor with
			<code class="special">{char}</code>.  This replaces in screen space, not file
			space.  See |<a href="change.html#gR">gR</a>| and |<a href="insert.html#Virtual-Replace-mode">Virtual-Replace-mode</a>| for more
			details.  As with |<a href="change.html#r">r</a>| a count may be given.
			<code class="special">{char}</code> can be entered like with |<a href="change.html#r">r</a>|.

						<b class="vimtag">*<a name="digraph-arg">digraph-arg</a>*</b>
The argument for Normal mode commands like |<a href="change.html#r">r</a>| and |<a href="motion.html#t">t</a>| is a single character.
When 'cpo' doesn't contain the 'D' flag, this character can also be entered
like |<a href="digraph.html#digraphs">digraphs</a>|.  First type <code class="keystroke">CTRL-K</code> and then the two digraph characters.
{not available when compiled without the |<a href="various.html#+digraphs">+digraphs</a>| feature}

						<b class="vimtag">*<a name="case">case</a>*</b>
The following commands change the case of letters.  The currently active
|<a href="mbyte.html#locale">locale</a>| is used.  See |<a href="mlang.html#:language">:language</a>|.  The LC_CTYPE value matters here.

							<b class="vimtag">*<a name="%7E">~</a>*</b>
~			'notildeop' option: Switch case of the character
			under the cursor and move the cursor to the right.
			If a <code class="special">[count]</code> is given, do that many characters.

~<code class="special">{motion}</code>		'tildeop' option: switch case of <code class="special">{motion}</code> text.

							<b class="vimtag">*<a name="g%7E">g~</a>*</b>
g~<code class="special">{motion}</code>		Switch case of <code class="special">{motion}</code> text.

g~g~							<b class="vimtag">*<a name="g%7Eg%7E">g~g~</a>*</b> <b class="vimtag">*<a name="g%7E%7E">g~~</a>*</b>
g~~			Switch case of current line.

							<b class="vimtag">*<a name="v_%7E">v_~</a>*</b>
<code class="special">{Visual}</code>~		Switch case of highlighted text (for <code class="special">{Visual}</code> see
			|<a href="visual.html#Visual-mode">Visual-mode</a>|).

							<b class="vimtag">*<a name="v_U">v_U</a>*</b>
<code class="special">{Visual}</code>U		Make highlighted text uppercase (for <code class="special">{Visual}</code> see
			|<a href="visual.html#Visual-mode">Visual-mode</a>|).

							<b class="vimtag">*<a name="gU">gU</a>*</b> <b class="vimtag">*<a name="uppercase">uppercase</a>*</b>
gU<code class="special">{motion}</code>		Make <code class="special">{motion}</code> text uppercase.
			Example:
<code class="example">				:map! <code class="special">&lt;C-F&gt;</code> <code class="special">&lt;Esc&gt;</code>gUiw`]a</code>
			This works in Insert mode: press <code class="keystroke">CTRL-F</code> to make the
			word before the cursor uppercase.  Handy to type
			words in lowercase and then make them uppercase.


gUgU							<b class="vimtag">*<a name="gUgU">gUgU</a>*</b> <b class="vimtag">*<a name="gUU">gUU</a>*</b>
gUU			Make current line uppercase.

							<b class="vimtag">*<a name="v_u">v_u</a>*</b>
<code class="special">{Visual}</code>u		Make highlighted text lowercase (for <code class="special">{Visual}</code> see
			|<a href="visual.html#Visual-mode">Visual-mode</a>|).

							<b class="vimtag">*<a name="gu">gu</a>*</b> <b class="vimtag">*<a name="lowercase">lowercase</a>*</b>
gu<code class="special">{motion}</code>		Make <code class="special">{motion}</code> text lowercase.

gugu							<b class="vimtag">*<a name="gugu">gugu</a>*</b> <b class="vimtag">*<a name="guu">guu</a>*</b>
guu			Make current line lowercase.

							<b class="vimtag">*<a name="g?">g?</a>*</b> <b class="vimtag">*<a name="rot13">rot13</a>*</b>
g?<code class="special">{motion}</code>		Rot13 encode <code class="special">{motion}</code> text.

							<b class="vimtag">*<a name="v_g?">v_g?</a>*</b>
<code class="special">{Visual}</code>g?		Rot13 encode the highlighted text (for <code class="special">{Visual}</code> see
			|<a href="visual.html#Visual-mode">Visual-mode</a>|).

g?g?							<b class="vimtag">*<a name="g?g?">g?g?</a>*</b> <b class="vimtag">*<a name="g??">g??</a>*</b>
g??			Rot13 encode current line.

To turn one line into title caps, make every first letter of a word
uppercase:
<code class="example">	:s/\v&lt;(.)(\w*)/\u\1\L\2/g</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">Adding and subtracting </code>
							<b class="vimtag">*<a name="CTRL-A">CTRL-A</a>*</b>
<code class="keystroke">CTRL-A</code>			Add <code class="special">[count]</code> to the number or alphabetic character at
			or after the cursor.

							<b class="vimtag">*<a name="v_CTRL-A">v_CTRL-A</a>*</b>
<code class="special">{Visual}</code><code class="keystroke">CTRL-A</code>		Add <code class="special">[count]</code> to the number or alphabetic character in
			the highlighted text.

							<b class="vimtag">*<a name="v_g_CTRL-A">v_g_CTRL-A</a>*</b>
<code class="special">{Visual}</code>g <code class="keystroke">CTRL-A</code>	Add <code class="special">[count]</code> to the number or alphabetic character in
			the highlighted text. If several lines are
		        highlighted, each one will be incremented by an
			additional <code class="special">[count]</code> (so effectively creating a
			<code class="special">[count]</code> incrementing sequence).
			For Example, if you have this list of numbers:
<code class="section">				1. </code>
<code class="section">				1. </code>
<code class="section">				1. </code>
<code class="section">				1. </code>
			Move to the second "1." and Visually select three
			lines, pressing g <code class="keystroke">CTRL-A</code> results in:
<code class="section">				1. </code>
<code class="section">				2. </code>
<code class="section">				3. </code>
<code class="section">				4. </code>

							<b class="vimtag">*<a name="CTRL-X">CTRL-X</a>*</b>
<code class="keystroke">CTRL-X</code>			Subtract <code class="special">[count]</code> from the number or alphabetic
			character at or after the cursor.

							<b class="vimtag">*<a name="v_CTRL-X">v_CTRL-X</a>*</b>
<code class="special">{Visual}</code><code class="keystroke">CTRL-X</code>		Subtract <code class="special">[count]</code> from the number or alphabetic
			character in the highlighted text.

			On MS-Windows, this is mapped to cut Visual text
			|<a href="os_dos.html#dos-standard-mappings">dos-standard-mappings</a>|.  If you want to disable the
			mapping, use this:
<code class="example">				silent! vunmap <code class="special">&lt;C-X&gt;</code></code>

							<b class="vimtag">*<a name="v_g_CTRL-X">v_g_CTRL-X</a>*</b>
<code class="special">{Visual}</code>g <code class="keystroke">CTRL-X</code>	Subtract <code class="special">[count]</code> from the number or alphabetic
			character in the highlighted text. If several lines
			are highlighted, each value will be decremented by an
			additional <code class="special">[count]</code> (so effectively creating a <code class="special">[count]</code>
			decrementing sequence).

The <code class="keystroke">CTRL-A</code> and <code class="keystroke">CTRL-X</code> commands can work for:
- signed and unsigned decimal numbers
- unsigned binary, octal and hexadecimal numbers
- alphabetic characters

This depends on the 'nrformats' option:
- When 'nrformats' includes "bin", Vim assumes numbers starting with '0b' or
  '0B' are binary.
- When 'nrformats' includes "octal", Vim considers numbers starting with a '0'
  to be octal, unless the number includes a '8' or '9'.  Other numbers are
  decimal and may have a preceding minus sign.
  If the cursor is on a number, the commands apply to that number; otherwise
  Vim uses the number to the right of the cursor.
- When 'nrformats' includes "hex", Vim assumes numbers starting with '0x' or
  '0X' are hexadecimal.  The case of the rightmost letter in the number
  determines the case of the resulting hexadecimal number.  If there is no
  letter in the current number, Vim uses the previously detected case.
- When 'nrformats' includes "alpha", Vim will change the alphabetic character
  under or after the cursor.  This is useful to make lists with an alphabetic
  index.

For decimals a leading negative sign is considered for incrementing/
decrementing, for binary, octal and hex values, it won't be considered.  To
ignore the sign Visually select the number before using <code class="keystroke">CTRL-A</code> or <code class="keystroke">CTRL-X</code>.

For numbers with leading zeros (including all octal and hexadecimal numbers),
Vim preserves the number of characters in the number when possible.  <code class="keystroke">CTRL-A</code> on
"0077" results in "0100", <code class="keystroke">CTRL-X</code> on "0x100" results in "0x0ff".
There is one exception: When a number that starts with a zero is found not to
be octal (it contains a '8' or '9'), but 'nrformats' does include "octal",
leading zeros are removed to avoid that the result may be recognized as an
octal number.

<code class="note">Note</code> that when 'nrformats' includes "octal", decimal numbers with leading
zeros cause mistakes, because they can be confused with octal numbers.

<code class="note">Note</code> similarly, when 'nrformats' includes "bin", binary numbers with a leading
'0x' or '0X' can be interpreted as hexadecimal rather than binary since '0b'
are valid hexadecimal digits.

The <code class="keystroke">CTRL-A</code> command is very useful in a macro.  Example: Use the following
steps to make a numbered list.

1. Create the first list entry, make sure it starts with a number.
2. qa	     - start recording into register 'a'
3. Y	     - yank the entry
4. p	     - put a copy of the entry below the first one
5. <code class="keystroke">CTRL-A</code>    - increment the number
6. q	     - stop recording
7. <code class="special">&lt;count&gt;</code>@a - repeat the yank, put and increment <code class="special">&lt;count&gt;</code> times


SHIFTING LINES LEFT OR RIGHT				<b class="vimtag">*<a name="shift-left-right">shift-left-right</a>*</b>

							<b class="vimtag">*<a name="%3C">&lt;</a>*</b>
&lt;<code class="special">{motion}</code>		Shift <code class="special">{motion}</code> lines one 'shiftwidth' leftwards.

			If the 'vartabstop' feature is enabled, and the
			'shiftwidth' option is set to zero, the amount of
			indent is calculated at the first non-blank character
			in the line.
							<b class="vimtag">*<a name="%3C%3C">&lt;&lt;</a>*</b>
&lt;&lt;			Shift <code class="special">[count]</code> lines one 'shiftwidth' leftwards.

							<b class="vimtag">*<a name="v_%3C">v_&lt;</a>*</b>
<code class="special">{Visual}</code><code class="special">[count]</code>&lt;	Shift the highlighted lines <code class="special">[count]</code> 'shiftwidth'
			leftwards (for <code class="special">{Visual}</code> see |<a href="visual.html#Visual-mode">Visual-mode</a>|).

							<b class="vimtag">*<a name="%3E">&gt;</a>*</b>
 &gt;<code class="special">{motion}</code>		Shift <code class="special">{motion}</code> lines one 'shiftwidth' rightwards.

			If the 'vartabstop' feature is enabled, and the
			'shiftwidth' option is set to zero, the amount of
			indent is calculated at the first non-blank character
			in the line.
							<b class="vimtag">*<a name="%3E%3E">&gt;&gt;</a>*</b>
 &gt;&gt;			Shift <code class="special">[count]</code> lines one 'shiftwidth' rightwards.

							<b class="vimtag">*<a name="v_%3E">v_&gt;</a>*</b>
<code class="special">{Visual}</code><code class="special">[count]</code>&gt;	Shift the highlighted lines <code class="special">[count]</code> 'shiftwidth'
			rightwards (for <code class="special">{Visual}</code> see |<a href="visual.html#Visual-mode">Visual-mode</a>|).

							<b class="vimtag">*<a name=":%3C">:&lt;</a>*</b>
:<code class="special">[range]</code>&lt;		Shift <code class="special">[range]</code> lines one 'shiftwidth' left.  Repeat '&lt;'
			for shifting multiple 'shiftwidth's.

:<code class="special">[range]</code>&lt; <code class="special">{count}</code>	Shift <code class="special">{count}</code> lines one 'shiftwidth' left, starting
			with <code class="special">[range]</code> (default current line |<a href="cmdline.html#cmdline-ranges">cmdline-ranges</a>|).
			Repeat '&lt;' for shifting multiple 'shiftwidth's.

:<code class="special">[range]</code>le[ft] [indent]	left align lines in <code class="special">[range]</code>.  Sets the indent in the
			lines to [indent] (default 0).

							<b class="vimtag">*<a name=":%3E">:&gt;</a>*</b>
:<code class="special">[range]</code>&gt; [flags]	Shift <code class="special">{count}</code> <code class="special">[range]</code> lines one 'shiftwidth' right.
			Repeat '&gt;' for shifting multiple 'shiftwidth's.
			See |<a href="cmdline.html#ex-flags">ex-flags</a>| for [flags].

:<code class="special">[range]</code>&gt; <code class="special">{count}</code> [flags]
			Shift <code class="special">{count}</code> lines one 'shiftwidth' right, starting
			with <code class="special">[range]</code> (default current line |<a href="cmdline.html#cmdline-ranges">cmdline-ranges</a>|).
			Repeat '&gt;' for shifting multiple 'shiftwidth's.
			See |<a href="cmdline.html#ex-flags">ex-flags</a>| for [flags].

The "&gt;" and "&lt;" commands are handy for changing the indentation within
programs.  Use the 'shiftwidth' option to set the size of the white space
which these commands insert or delete.  Normally the 'shiftwidth' option is 8,
but you can set it to, say, 3 to make smaller indents.  The shift leftwards
stops when there is no indent.  The shift right does not affect empty lines.

If the 'shiftround' option is on, the indent is rounded to a multiple of
'shiftwidth'.

If the 'smartindent' option is on, or 'cindent' is on and 'cinkeys' contains
'#' with a zero value, shift right does not affect lines starting with '#'
(these are supposed to be C preprocessor lines that must stay in column 1).
This can be changed with the 'cino' option, see |<a href="indent.html#cino-%23">cino-#</a>|.

When the 'expandtab' option is off (this is the default) Vim uses <code class="special">&lt;Tab&gt;</code>s as
much as possible to make the indent.  You can use "&gt;&gt;&lt;&lt;" to replace an indent
made out of spaces with the same indent made out of <code class="special">&lt;Tab&gt;</code>s (and a few spaces
if necessary).  If the 'expandtab' option is on, Vim uses only spaces.  Then
you can use "&gt;&gt;<code class="special">&lt;&lt;" to replace &lt;Tab&gt;</code>s in the indent by spaces (or use
`:retab!`).

To move a line several 'shiftwidth's, use Visual mode or the `:` commands.
For example:
<code class="example">	Vjj4&gt;		move three lines 4 indents to the right</code>
<code class="example">	:&lt;&lt;&lt;		move current line 3 indents to the left</code>
<code class="example">	:&gt;&gt; 5		move 5 lines 2 indents to the right</code>
<code class="example">	:5&gt;&gt;		move line 5 2 indents to the right</code>
<code class="example"></code>
</pre><hr/><pre>4. Complex changes					<b class="vimtag">*<a name="complex-change">complex-change</a>*</b>

4.1 Filter commands					<b class="vimtag">*<a name="filter">filter</a>*</b>

A filter is a program that accepts text at standard input, changes it in some
way, and sends it to standard output.  You can use the commands below to send
some text through a filter, so that it is replaced by the filter output.
Examples of filters are "sort", which sorts lines alphabetically, and
"indent", which formats C program files (you need a version of indent that
works like a filter; not all versions do).  The 'shell' option specifies the
shell Vim uses to execute the filter command (See also the 'shelltype'
option).  You can repeat filter commands with ".".  Vim does not recognize a
comment (starting with '"') after the `:!` command.

							<b class="vimtag">*<a name="!">!</a>*</b>
!<code class="special">{motion}</code><code class="special">{filter}</code>	Filter <code class="special">{motion}</code> text lines through the external
			program <code class="special">{filter}</code>.

							<b class="vimtag">*<a name="!!">!!</a>*</b>
!!<code class="special">{filter}</code>		Filter <code class="special">[count]</code> lines through the external program
			<code class="special">{filter}</code>.

							<b class="vimtag">*<a name="v_!">v_!</a>*</b>
<code class="special">{Visual}</code>!<code class="special">{filter}</code>	Filter the highlighted lines through the external
			program <code class="special">{filter}</code> (for <code class="special">{Visual}</code> see |<a href="visual.html#Visual-mode">Visual-mode</a>|).

:<code class="special">{range}</code>![!]<code class="special">{filter}</code> [!][arg]				<b class="vimtag">*<a name=":range!">:range!</a>*</b>
			Filter <code class="special">{range}</code> lines through the external program
			<code class="special">{filter}</code>.  Vim replaces the optional bangs with the
			latest given command and appends the optional [arg].
			Vim saves the output of the filter command in a
			temporary file and then reads the file into the buffer
			|<a href="change.html#tempfile">tempfile</a>|.  Vim uses the 'shellredir' option to
			redirect the filter output to the temporary file.
			However, if the 'shelltemp' option is off then pipes
			are used when possible (on Unix).
			When the 'R' flag is included in 'cpoptions' marks in
			the filtered lines are deleted, unless the
			|<a href="motion.html#:keepmarks">:keepmarks</a>| command is used.  Example:
<code class="example">				:keepmarks '<code class="special">&lt;,'&gt;</code>!sort</code>
			When the number of lines after filtering is less than
			before, marks in the missing lines are deleted anyway.

							<b class="vimtag">*<a name="%20">=</a>*</b>
=<code class="special">{motion}</code>		Filter <code class="special">{motion}</code> lines through the external program
			given with the 'equalprg' option.  When the 'equalprg'
			option is empty (this is the default), use the
			internal formatting function |<a href="indent.html#C-indenting">C-indenting</a>| and
			|<a href="options.html#'lisp'">'lisp'</a>|.  But when 'indentexpr' is not empty, it will
			be used instead |<a href="indent.html#indent-expression">indent-expression</a>|.  When Vim was
			compiled without internal formatting then the "indent"
			program is used as a last resort.

							<b class="vimtag">*<a name="%20%20">==</a>*</b>
==			Filter <code class="special">[count]</code> lines like with =<code class="special">{motion}</code>.

							<b class="vimtag">*<a name="v_%20">v_=</a>*</b>
<code class="special">{Visual}</code>=		Filter the highlighted lines like with =<code class="special">{motion}</code>.


						<b class="vimtag">*<a name="tempfile">tempfile</a>*</b> <b class="vimtag">*<a name="setuid">setuid</a>*</b>
Vim uses temporary files for filtering, generating diffs and also for
tempname().  For Unix, the file will be in a private directory (only
accessible by the current user) to avoid security problems (e.g., a symlink
attack or other people reading your file).  When Vim exits the directory and
all files in it are deleted.  When Vim has the setuid bit set this may cause
problems, the temp file is owned by the setuid user but the filter command
probably runs as the original user.
On MS-Windows the first of these directories that works is used: $TMP,
$TEMP, c:\TMP, c:\TEMP.
For Unix the list of directories is: $TMPDIR, /tmp, current-dir, $HOME.
For MS-Windows the GetTempFileName() system function is used.
For other systems the tmpnam() library function is used.



4.2 Substitute						<b class="vimtag">*<a name=":substitute">:substitute</a>*</b>
							<b class="vimtag">*<a name=":s">:s</a>*</b> <b class="vimtag">*<a name=":su">:su</a>*</b>
:<code class="special">[range]</code>s[ubstitute]/<code class="special">{pattern}</code>/<code class="special">{string}</code>/[flags] <code class="special">[count]</code>
			For each line in <code class="special">[range]</code> replace a match of <code class="special">{pattern}</code>
			with <code class="special">{string}</code>.
			For the <code class="special">{pattern}</code> see |<a href="pattern.html#pattern">pattern</a>|.
			<code class="special">{string}</code> can be a literal string, or something
			special; see |<a href="change.html#sub-replace-special">sub-replace-special</a>|.
			When <code class="special">[range]</code> and <code class="special">[count]</code> are omitted, replace in the
			current line only.  When <code class="special">[count]</code> is given, replace in
			<code class="special">[count]</code> lines, starting with the last line in <code class="special">[range]</code>.
			When <code class="special">[range]</code> is omitted start in the current line.
							<b class="vimtag">*<a name="E939">E939</a>*</b>
			<code class="special">[count]</code> must be a positive number.  Also see
			|<a href="cmdline.html#cmdline-ranges">cmdline-ranges</a>|.

			See |<a href="change.html#:s_flags">:s_flags</a>| for [flags].
			The delimiter doesn't need to be /, see
			|<a href="change.html#pattern-delimiter">pattern-delimiter</a>|.

:<code class="special">[range]</code>s[ubstitute] [flags] <code class="special">[count]</code>
:<code class="special">[range]</code>&amp;[&amp;][flags] <code class="special">[count]</code>					<b class="vimtag">*<a name=":&">:&amp;</a>*</b>
			Repeat last :substitute with same search pattern and
			substitute string, but without the same flags.  You
			may add [flags], see |<a href="change.html#:s_flags">:s_flags</a>|.
			<code class="note">Note</code> that after `:substitute` the '&amp;' flag can't be
			used, it's recognized as a pattern separator.
			The space between `:substitute` and the 'c', 'g',
			'i', 'I' and 'r' flags isn't required, but in scripts
			it's a good idea to keep it to avoid confusion.

:<code class="special">[range]</code>~[&amp;][flags] <code class="special">[count]</code>					<b class="vimtag">*<a name=":%7E">:~</a>*</b>
			Repeat last substitute with same substitute string
			but with last used search pattern.  This is like
			`:&amp;r`.  See |<a href="change.html#:s_flags">:s_flags</a>| for [flags].

								<b class="vimtag">*<a name="&">&amp;</a>*</b>
&amp;			Synonym for `:s` (repeat last substitute).  <code class="note">Note</code>
			that the flags are not remembered, thus it might
			actually work differently.  You can use `:&amp;&amp;` to keep
			the flags.

								<b class="vimtag">*<a name="g&">g&amp;</a>*</b>
g&amp;			Synonym for `:%s//~/&amp;` (repeat last substitute with
			last search pattern on all lines with the same flags).
			For example, when you first do a substitution with
			`:s/pattern/repl/flags` and then `/search` for
			something else, `g&amp;` will do `:%s/search/repl/flags`.
			Mnemonic: global substitute.

						<b class="vimtag">*<a name=":snomagic">:snomagic</a>*</b> <b class="vimtag">*<a name=":sno">:sno</a>*</b>
:<code class="special">[range]</code>sno[magic] ...	Same as `:substitute`, but always use 'nomagic'.

						<b class="vimtag">*<a name=":smagic">:smagic</a>*</b> <b class="vimtag">*<a name=":sm">:sm</a>*</b>
:<code class="special">[range]</code>sm[agic] ...	Same as `:substitute`, but always use 'magic'.

							<b class="vimtag">*<a name=":s_flags">:s_flags</a>*</b>
The flags that you can use for the substitute commands:

							<b class="vimtag">*<a name=":&&">:&amp;&amp;</a>*</b>
[&amp;]	Must be the first one: Keep the flags from the previous substitute
	command.  Examples:
<code class="example">		:&amp;&amp;</code>
<code class="example">		:s/this/that/&amp;</code>
	<code class="note">Note</code> that `:s` and `:&amp;` don't keep the flags.

[c]	Confirm each substitution.  Vim highlights the matching string (with
	|<a href="syntax.html#hl-IncSearch">hl-IncSearch</a>|).  You can type:				<b class="vimtag">*<a name=":s_c">:s_c</a>*</b>
	    'y'	    to substitute this match
	    'l'	    to substitute this match and then quit ("last")
	    'n'	    to skip this match
	    <code class="special">&lt;Esc&gt;</code>   to quit substituting
	    'a'	    to substitute this and all remaining matches
	    'q'	    to quit substituting
	    <code class="keystroke">CTRL-E</code>  to scroll the screen up
	    <code class="keystroke">CTRL-Y</code>  to scroll the screen down
	If the 'edcompatible' option is on, Vim remembers the [c] flag and
	toggles it each time you use it, but resets it when you give a new
	search pattern.

							<b class="vimtag">*<a name=":s_e">:s_e</a>*</b>
[e]     When the search pattern fails, do not issue an error message and, in
	particular, continue in maps as if no error occurred.  This is most
	useful to prevent the "No match" error from breaking a mapping.  Vim
	does not suppress the following error messages, however:
		Regular expressions can't be delimited by letters
		\ should be followed by /, ? or &amp;
		No previous substitute regular expression
		Trailing characters
		Interrupted

							<b class="vimtag">*<a name=":s_g">:s_g</a>*</b>
[g]	Replace all occurrences in the line.  Without this argument,
	replacement occurs only for the first occurrence in each line.  If
	the 'edcompatible' option is on, Vim remembers this flag and toggles
	it each time you use it, but resets it when you give a new search
	pattern.  If the 'gdefault' option is on, this flag is on by default
	and the [g] argument switches it off.

							<b class="vimtag">*<a name=":s_i">:s_i</a>*</b>
[i]	Ignore case for the pattern.  The 'ignorecase' and 'smartcase' options
	are not used.

							<b class="vimtag">*<a name=":s_I">:s_I</a>*</b>
[I]	Don't ignore case for the pattern.  The 'ignorecase' and 'smartcase'
	options are not used.

							<b class="vimtag">*<a name=":s_n">:s_n</a>*</b>
[n]	Report the number of matches, do not actually substitute.  The [c]
	flag is ignored.  The matches are reported as if 'report' is zero.
	Useful to |<a href="tips.html#count-items">count-items</a>|.
	If \= |<a href="change.html#sub-replace-expression">sub-replace-expression</a>| is used, the expression will be
	evaluated in the |<a href="eval.html#sandbox">sandbox</a>| at every match.

[p]	Print the line containing the last substitute.  <b class="vimtag">*<a name=":s_p">:s_p</a>*</b>

[#]	Like [p] and prepend the line number.  <b class="vimtag">*<a name=":s_%23">:s_#</a>*</b>

[l]	Like [p] but print the text like |<a href="various.html#:list">:list</a>|.  <b class="vimtag">*<a name=":s_l">:s_l</a>*</b>

							<b class="vimtag">*<a name=":s_r">:s_r</a>*</b>
[r]	Only useful in combination with `:&amp;` or `:s` without arguments.  `:&amp;r`
	works the same way as `:~`:  When the search pattern is empty, use the
	previously used search pattern instead of the search pattern from the
	last substitute or `:global`.  If the last command that did a search
	was a substitute or `:global`, there is no effect.  If the last
	command was a search command such as "/", use the pattern from that
	command.
	For `:s` with an argument this already happens:
<code class="example">		:s/blue/red/</code>
<code class="example">		/green</code>
<code class="example">		:s//red/   or  :~   or  :&amp;r</code>
&lt;	The last commands will replace "green" with "red".
<code class="example">		:s/blue/red/</code>
<code class="example">		/green</code>
<code class="example">		:&amp;</code>
	The last command will replace "blue" with "red".

<code class="note">Note</code> that there is no flag to change the "magicness" of the pattern.  A
different command is used instead, or you can use |<a href="pattern.html#%2F\v">/\v</a>| and friends.  The
reason is that the flags can only be found by skipping the pattern, and in
order to skip the pattern the "magicness" must be known.  Catch 22!

If the <code class="special">{pattern}</code> for the substitute command is empty, the command uses the
pattern from the last substitute or `:global` command.  If there is none, but
there is a previous search pattern, that one is used.  With the [r] flag, the
command uses the pattern from the last substitute, `:global`, or search
command.

If the <code class="special">{string}</code> is omitted the substitute is done as if it's empty.  Thus the
matched pattern is deleted.  The separator after <code class="special">{pattern}</code> can also be left
out then.  Example:
<code class="example">	:%s/TESTING</code>
This deletes "TESTING" from all lines, but only one per line.

For compatibility with Vi these two exceptions are allowed:
"\/<code class="special">{string}</code>/" and "\?<code class="special">{string}</code>?" do the same as "//<code class="special">{string}</code>/r".
"\&amp;<code class="special">{string}</code>&amp;" does the same as "//<code class="special">{string}</code>/".
						<b class="vimtag">*<a name="pattern-delimiter">pattern-delimiter</a>*</b> <b class="vimtag">*<a name="E146">E146</a>*</b>
Instead of the '/' which surrounds the pattern and replacement string, you
can use any other single-byte character, but not an alphanumeric character,
'\', '"' or '|'.  This is useful if you want to include a '/' in the search
pattern or replacement string.  Example:
<code class="example">	:s+/+//+</code>
<code class="example"></code>
For the definition of a pattern, see |<a href="pattern.html#pattern">pattern</a>|.  In Visual block mode, use
|<a href="pattern.html#%2F\%V">/\%V</a>| in the pattern to have the substitute work in the block only.
Otherwise it works on whole lines anyway.

					<b class="vimtag">*<a name="sub-replace-special">sub-replace-special</a>*</b> <b class="vimtag">*<a name=":s\%20">:s\=</a>*</b>
When the <code class="special">{string}</code> starts with "\=" it is evaluated as an expression, see
|<a href="change.html#sub-replace-expression">sub-replace-expression</a>|.  You can use that for complex replacement or special
characters.

Otherwise these characters in <code class="special">{string}</code> have a special meaning:
								<b class="vimtag">*<a name=":s%">:s%</a>*</b>
When <code class="special">{string}</code> is equal to "%" and '/' is included with the 'cpoptions' option,
then the <code class="special">{string}</code> of the previous substitute command is used, see |<a href="options.html#cpo-%2F">cpo-/</a>|

<code class="section">magic	nomagic	  action    </code>
  &amp;	  \&amp;	  replaced with the whole matched pattern	     <b class="vimtag">*<a name="s%2F\&">s/\&amp;</a>*</b>
 \&amp;	   &amp;	  replaced with &amp;
      \0	  replaced with the whole matched pattern	   <b class="vimtag">*<a name="\0">\0</a>*</b> <b class="vimtag">*<a name="s%2F\0">s/\0</a>*</b>
      \1	  replaced with the matched pattern in the first
		  pair of ()					     <b class="vimtag">*<a name="s%2F\1">s/\1</a>*</b>
      \2	  replaced with the matched pattern in the second
		  pair of ()					     <b class="vimtag">*<a name="s%2F\2">s/\2</a>*</b>
      ..	  ..						     <b class="vimtag">*<a name="s%2F\3">s/\3</a>*</b>
      \9	  replaced with the matched pattern in the ninth
		  pair of ()					     <b class="vimtag">*<a name="s%2F\9">s/\9</a>*</b>
  ~	  \~	  replaced with the <code class="special">{string}</code> of the previous
		  substitute					     <b class="vimtag">*<a name="s%7E">s~</a>*</b>
 \~	   ~	  replaced with ~				     <b class="vimtag">*<a name="s%2F\%7E">s/\~</a>*</b>
      \u	  next character made uppercase			     <b class="vimtag">*<a name="s%2F\u">s/\u</a>*</b>
      \U	  following characters made uppercase, until \E      <b class="vimtag">*<a name="s%2F\U">s/\U</a>*</b>
      \l	  next character made lowercase			     <b class="vimtag">*<a name="s%2F\l">s/\l</a>*</b>
      \L	  following characters made lowercase, until \E      <b class="vimtag">*<a name="s%2F\L">s/\L</a>*</b>
      \e	  end of \u, \U, \l and \L (<code class="note">NOTE:</code> not <code class="special">&lt;Esc&gt;</code>!)	     <b class="vimtag">*<a name="s%2F\e">s/\e</a>*</b>
      \E	  end of \u, \U, \l and \L			     <b class="vimtag">*<a name="s%2F\E">s/\E</a>*</b>
      <code class="special">&lt;CR&gt;</code>	  split line in two at this point
		  (Type the <code class="special">&lt;CR&gt;</code> as <code class="keystroke">CTRL-V</code> <code class="special">&lt;Enter&gt;</code>)		     <b class="vimtag">*<a name="s%3CCR%3E">s&lt;CR&gt;</a>*</b>
      \r	  idem						     <b class="vimtag">*<a name="s%2F\r">s/\r</a>*</b>
      \<code class="special">&lt;CR&gt;</code>	  insert a carriage-return (<code class="keystroke">CTRL-M</code>)
		  (Type the <code class="special">&lt;CR&gt;</code> as <code class="keystroke">CTRL-V</code> <code class="special">&lt;Enter&gt;</code>)		     <b class="vimtag">*<a name="s%2F\%3CCR%3E">s/\&lt;CR&gt;</a>*</b>
      \n	  insert a <code class="special">&lt;NL&gt;</code> (<code class="special">&lt;NUL&gt;</code> in the file)
		  (does NOT break the line)			     <b class="vimtag">*<a name="s%2F\n">s/\n</a>*</b>
      \b	  insert a <code class="special">&lt;BS&gt;</code>					     <b class="vimtag">*<a name="s%2F\b">s/\b</a>*</b>
      \t	  insert a <code class="special">&lt;Tab&gt;</code>				     <b class="vimtag">*<a name="s%2F\t">s/\t</a>*</b>
      \\	  insert a single backslash			     <b class="vimtag">*<a name="s%2F\\">s/\\</a>*</b>
      \x	  where x is any character not mentioned above:
		  Reserved for future expansion

The special meaning is also used inside the third argument <code class="special">{sub}</code> of
the |<a href="eval.html#substitute()">substitute()</a>| function with the following exceptions:
  - A % inserts a percent literally without regard to 'cpoptions'.
  - magic is always set without regard to 'magic'.
  - A ~ inserts a tilde literally.
  - <code class="special">&lt;CR&gt;</code> and \r inserts a carriage-return (<code class="keystroke">CTRL-M</code>).
  - \<code class="special">&lt;CR&gt;</code> does not have a special meaning. It's just one of \x.

Examples:
<code class="example">  :s/a\|b/xxx\0xxx/g		 modifies "a b"	     to "xxxaxxx xxxbxxx"</code>
<code class="example">  :s/\([abc]\)\([efg]\)/\2\1/g	 modifies "af fa bg" to "fa fa gb"</code>
<code class="example">  :s/abcde/abc^Mde/		 modifies "abcde"    to "abc", "de" (two lines)</code>
<code class="example">  :s/$/\^M/			 modifies "abcde"    to "abcde^M"</code>
<code class="example">  :s/\w\+/\u\0/g		 modifies "bla bla"  to "Bla Bla"</code>
<code class="example">  :s/\w\+/\L\u\0/g		 modifies "BLA bla"  to "Bla Bla"</code>
<code class="example"></code>
<code class="note">Note:</code> "\L\u" can be used to capitalize the first letter of a word.  This is
not compatible with Vi and older versions of Vim, where the "\u" would cancel
out the "\L". Same for "\U\l".

<code class="note">Note:</code> In previous versions <code class="keystroke">CTRL-V</code> was handled in a special way.  Since this is
not Vi compatible, this was removed.  Use a backslash instead.

<code class="section">command		text	result </code>
:s/aa/a^Ma/	aa	a<code class="special">&lt;line-break&gt;</code>a
:s/aa/a\^Ma/	aa	a^Ma
:s/aa/a\\^Ma/	aa	a\<code class="special">&lt;line-break&gt;</code>a

(you need to type <code class="keystroke">CTRL-V</code> <code class="special">&lt;CR&gt;</code> to get a ^M here)

The numbering of "\1", "\2" etc. is done based on which "\(" comes first in
the pattern (going left to right).  When a parentheses group matches several
times, the last one will be used for "\1", "\2", etc.  Example:
<code class="example">  :s/\(\(a[a-d] \)*\)/\2/      modifies "aa ab x" to "ab x"</code>
The "\2" is for "\(a[a-d] \)".  At first it matches "aa ", secondly "ab ".

When using parentheses in combination with '|<code class="badlink">', like in \([ab]\)\</code>|\([cd]\),
either the first or second pattern in parentheses did not match, so either
\1 or \2 is empty.  Example:
<code class="example">  :s/\([ab]\)\|\([cd]\)/\1x/g   modifies "a b c d"  to "ax bx x x"</code>


		<b class="vimtag">*<a name=":sc">:sc</a>*</b> <b class="vimtag">*<a name=":sce">:sce</a>*</b> <b class="vimtag">*<a name=":scg">:scg</a>*</b> <b class="vimtag">*<a name=":sci">:sci</a>*</b> <b class="vimtag">*<a name=":scI">:scI</a>*</b> <b class="vimtag">*<a name=":scl">:scl</a>*</b> <b class="vimtag">*<a name=":scp">:scp</a>*</b> <b class="vimtag">*<a name=":sg">:sg</a>*</b> <b class="vimtag">*<a name=":sgc">:sgc</a>*</b>
		<b class="vimtag">*<a name=":sge">:sge</a>*</b> <b class="vimtag">*<a name=":sgi">:sgi</a>*</b> <b class="vimtag">*<a name=":sgI">:sgI</a>*</b> <b class="vimtag">*<a name=":sgl">:sgl</a>*</b> <b class="vimtag">*<a name=":sgn">:sgn</a>*</b> <b class="vimtag">*<a name=":sgp">:sgp</a>*</b> <b class="vimtag">*<a name=":sgr">:sgr</a>*</b> <b class="vimtag">*<a name=":sI">:sI</a>*</b> <b class="vimtag">*<a name=":si">:si</a>*</b>
		<b class="vimtag">*<a name=":sic">:sic</a>*</b> <b class="vimtag">*<a name=":sIc">:sIc</a>*</b> <b class="vimtag">*<a name=":sie">:sie</a>*</b> <b class="vimtag">*<a name=":sIe">:sIe</a>*</b> <b class="vimtag">*<a name=":sIg">:sIg</a>*</b> <b class="vimtag">*<a name=":sIl">:sIl</a>*</b> <b class="vimtag">*<a name=":sin">:sin</a>*</b> <b class="vimtag">*<a name=":sIn">:sIn</a>*</b> <b class="vimtag">*<a name=":sIp">:sIp</a>*</b>
		<b class="vimtag">*<a name=":sip">:sip</a>*</b> <b class="vimtag">*<a name=":sIr">:sIr</a>*</b> <b class="vimtag">*<a name=":sir">:sir</a>*</b> <b class="vimtag">*<a name=":sr">:sr</a>*</b> <b class="vimtag">*<a name=":src">:src</a>*</b> <b class="vimtag">*<a name=":srg">:srg</a>*</b> <b class="vimtag">*<a name=":sri">:sri</a>*</b> <b class="vimtag">*<a name=":srI">:srI</a>*</b> <b class="vimtag">*<a name=":srl">:srl</a>*</b>
		<b class="vimtag">*<a name=":srn">:srn</a>*</b> <b class="vimtag">*<a name=":srp">:srp</a>*</b>
<code class="section">2-letter and 3-letter :substitute commands </code>

     List of :substitute commands
     |      c    e    g    i    I    n    p    l    r
     | c  :sc  :sce :scg :sci :scI :scn :scp :scl  ---
     | e
     | g  :sgc :sge :sg  :sgi :sgI :sgn :sgp :sgl :sgr
     | i  :sic :sie  --- :si  :siI :sin :sip  --- :sir
     | I  :sIc :sIe :sIg :sIi :sI  :sIn :sIp :sIl :sIr
     | n
     | p
     | l
     | r  :src  --- :srg :sri :srI :srn :srp :srl :sr

Exceptions:
     :scr  is  `:scriptnames`
     :se   is  `:set`
     :sig  is  `:sign`
     :sil  is  `:silent`
     :sn   is  `:snext`
     :sp   is  `:split`
     :sl   is  `:sleep`
     :sre  is  `:srewind`


Substitute with an expression			<b class="vimtag">*<a name="sub-replace-expression">sub-replace-expression</a>*</b>
						<b class="vimtag">*<a name="sub-replace-\%20">sub-replace-\=</a>*</b> <b class="vimtag">*<a name="s%2F\%20">s/\=</a>*</b>
When the substitute string starts with "\=" the remainder is interpreted as an
expression.

The special meaning for characters as mentioned at |<a href="change.html#sub-replace-special">sub-replace-special</a>| does
not apply except for "<code class="special">&lt;CR&gt;</code>".  A <code class="special">&lt;NL&gt;</code> character is used as a line break, you
can get one with a double-quote string: "\n".  Prepend a backslash to get a
real <code class="special">&lt;NL&gt;</code> character (which will be a NUL in the file).

The "\=" notation can also be used inside the third argument <code class="special">{sub}</code> of
|<a href="eval.html#substitute()">substitute()</a>| function.  In this case, the special meaning for characters as
mentioned at |<a href="change.html#sub-replace-special">sub-replace-special</a>| does not apply at all. Especially, <code class="special">&lt;CR&gt;</code> and
<code class="special">&lt;NL&gt;</code> are interpreted not as a line break but as a carriage-return and a
new-line respectively.

When the result is a |<a href="eval.html#List">List</a>| then the items are joined with separating line
breaks.  Thus each item becomes a line, except that they can contain line
breaks themselves.

The |<a href="eval.html#submatch()">submatch()</a>| function can be used to obtain matched text.  The whole
matched text can be accessed with "submatch(0)".  The text matched with the
first pair of () with "submatch(1)".  Likewise for further sub-matches in ().

Be careful: The separation character must not appear in the expression!
Consider using a character like "@" or ":".  There is no problem if the result
of the expression contains the separation character.

Examples:
<code class="example">	:s@\n@\="\r" . expand("$HOME") . "\r"@</code>
This replaces an end-of-line with a new line containing the value of $HOME.
<code class="example"></code>
<code class="example">	s/E/\="\<code class="special">&lt;Char-0x20ac&gt;</code>"/g</code>
This replaces each 'E' character with a euro sign.  Read more in |<a href="map.html#%3CChar-%3E">&lt;Char-&gt;</a>|.


4.3 Search and replace					<b class="vimtag">*<a name="search-replace">search-replace</a>*</b>

							<b class="vimtag">*<a name=":pro">:pro</a>*</b> <b class="vimtag">*<a name=":promptfind">:promptfind</a>*</b>
:promptf[ind] [string]
			Put up a Search dialog.  When [string] is given, it is
			used as the initial search string.
			<code class="special">{only for Win32, Motif and GTK GUI}</code>

						<b class="vimtag">*<a name=":promptr">:promptr</a>*</b> <b class="vimtag">*<a name=":promptrepl">:promptrepl</a>*</b>
:promptr[epl] [string]
			Put up a Search/Replace dialog.  When [string] is
			given, it is used as the initial search string.
			<code class="special">{only for Win32, Motif and GTK GUI}</code>


4.4 Changing tabs					<b class="vimtag">*<a name="change-tabs">change-tabs</a>*</b>
							<b class="vimtag">*<a name=":ret">:ret</a>*</b> <b class="vimtag">*<a name=":retab">:retab</a>*</b> <b class="vimtag">*<a name=":retab!">:retab!</a>*</b>
:<code class="special">[range]</code>ret[ab][!] [new_tabstop]
			Replace all sequences of white-space containing a
			<code class="special">&lt;Tab&gt;</code> with new strings of white-space using the new
			tabstop value given.  If you do not specify a new
			tabstop size or it is zero, Vim uses the current value
			of 'tabstop'.
			The current value of 'tabstop' is always used to
			compute the width of existing tabs.
			With !, Vim also replaces strings of only normal
			spaces with tabs where appropriate.
			With 'expandtab' on, Vim replaces all tabs with the
			appropriate number of spaces.
			This command sets 'tabstop' to the new value given,
			and if performed on the whole file, which is default,
			should not make any visible change.
			Careful: This command modifies any <code class="special">&lt;Tab&gt;</code> characters
			inside of strings in a C program.  Use "\t" to avoid
			this (that's a good habit anyway).
			`:retab!` may also change a sequence of spaces by
			<code class="special">&lt;Tab&gt;</code> characters, which can mess up a printf().
			If the |<a href="various.html#+vartabs">+vartabs</a>| feature is enabled then a list of
			tab widths separated by commas may be used in place of
			a single tabstop.  Each value in the list represents
			the width of one tabstop, except the final value which
			applies to all following tabstops.

							<b class="vimtag">*<a name="retab-example">retab-example</a>*</b>
Example for using autocommands and ":retab" to edit a file which is stored
with tabstops at 8 but edited with tabstops set at 4.  Warning: white space
inside of strings can change!  Also see 'softtabstop' option.
<code class="example"></code>
<code class="example">  :auto BufReadPost	*.xx	retab! 4</code>
<code class="example">  :auto BufWritePre	*.xx	retab! 8</code>
<code class="example">  :auto BufWritePost	*.xx	retab! 4</code>
<code class="example">  :auto BufNewFile	*.xx	set ts=4</code>
<code class="example"></code>
</pre><hr/><pre>5. Copying and moving text				<b class="vimtag">*<a name="copy-move">copy-move</a>*</b>

							<b class="vimtag">*<a name="quote">quote</a>*</b>
"<code class="special">{a-zA-Z0-9.%#:-"}</code>	Use register <code class="special">{a-zA-Z0-9.%#:-"}</code> for next delete, yank
			or put (use uppercase character to append with
			delete and yank) (<code class="special">{.%#:}</code> only work with put).

							<b class="vimtag">*<a name=":reg">:reg</a>*</b> <b class="vimtag">*<a name=":registers">:registers</a>*</b>
:reg[isters]		Display the type and contents of all numbered and
			named registers.  If a register is written to for
			|<a href="various.html#:redir">:redir</a>| it will not be listed.
			Type can be one of:
			"c"	for |<a href="motion.html#characterwise">characterwise</a>| text
			"l"	for |<a href="motion.html#linewise">linewise</a>| text
			"b"	for |<a href="visual.html#blockwise-visual">blockwise-visual</a>| text


:reg[isters] <code class="special">{arg}</code>	Display the contents of the numbered and named
			registers that are mentioned in <code class="special">{arg}</code>.  For example:
<code class="example">				:reg 1a</code>
			to display registers '1' and 'a'.  Spaces are allowed
			in <code class="special">{arg}</code>.

							<b class="vimtag">*<a name=":di">:di</a>*</b> <b class="vimtag">*<a name=":display">:display</a>*</b>
:di[splay] [arg]	Same as :registers.

							<b class="vimtag">*<a name="y">y</a>*</b> <b class="vimtag">*<a name="yank">yank</a>*</b>
["x]y<code class="special">{motion}</code>		Yank <code class="special">{motion}</code> text [into register x].  When no
			characters are to be yanked (e.g., "y0" in column 1),
			this is an error when 'cpoptions' includes the 'E'
			flag.

							<b class="vimtag">*<a name="yy">yy</a>*</b>
["x]yy			Yank <code class="special">[count]</code> lines [into register x] |<a href="motion.html#linewise">linewise</a>|.

							<b class="vimtag">*<a name="Y">Y</a>*</b>
["x]Y			yank <code class="special">[count]</code> lines [into register x] (synonym for
			yy, |<a href="motion.html#linewise">linewise</a>|).  If you like "Y" to work from the
			cursor to the end of line (which is more logical,
			but not Vi-compatible) use ":map Y y$".

							<b class="vimtag">*<a name="v_y">v_y</a>*</b>
<code class="special">{Visual}</code>["x]y		Yank the highlighted text [into register x] (for
			<code class="special">{Visual}</code> see |<a href="visual.html#Visual-mode">Visual-mode</a>|).

							<b class="vimtag">*<a name="v_Y">v_Y</a>*</b>
<code class="special">{Visual}</code>["x]Y		Yank the highlighted lines [into register x] (for
			<code class="special">{Visual}</code> see |<a href="visual.html#Visual-mode">Visual-mode</a>|).

							<b class="vimtag">*<a name=":y">:y</a>*</b> <b class="vimtag">*<a name=":yank">:yank</a>*</b> <b class="vimtag">*<a name="E850">E850</a>*</b>
:<code class="special">[range]</code>y[ank] [x]	Yank <code class="special">[range]</code> lines [into register x]. Yanking to the
			"* or "+ registers is possible only when the
			|<a href="various.html#+clipboard">+clipboard</a>| feature is included.

:<code class="special">[range]</code>y[ank] [x] <code class="special">{count}</code>
			Yank <code class="special">{count}</code> lines, starting with last line number
			in <code class="special">[range]</code> (default: current line |<a href="cmdline.html#cmdline-ranges">cmdline-ranges</a>|),
			[into register x].

							<b class="vimtag">*<a name="p">p</a>*</b> <b class="vimtag">*<a name="put">put</a>*</b> <b class="vimtag">*<a name="E353">E353</a>*</b>
["x]p			Put the text [from register x] after the cursor
			<code class="special">[count]</code> times.

							<b class="vimtag">*<a name="P">P</a>*</b>
["x]P			Put the text [from register x] before the cursor
			<code class="special">[count]</code> times.

							<b class="vimtag">*<a name="%3CMiddleMouse%3E">&lt;MiddleMouse&gt;</a>*</b>
["x]<code class="special">&lt;MiddleMouse&gt;</code>	Put the text from a register before the cursor <code class="special">[count]</code>
			times.  Uses the "* register, unless another is
			specified.
			Leaves the cursor at the end of the new text.
			Using the mouse only works when 'mouse' contains 'n'
			or 'a'.
			If you have a scrollwheel and often accidentally paste
			text, you can use these mappings to disable the
			pasting with the middle mouse button:
<code class="example">				:map <code class="special">&lt;MiddleMouse&gt;</code> <code class="special">&lt;Nop&gt;</code></code>
<code class="example">				:imap <code class="special">&lt;MiddleMouse&gt;</code> <code class="special">&lt;Nop&gt;</code></code>
			You might want to disable the multi-click versions
			too, see |<a href="term.html#double-click">double-click</a>|.

							<b class="vimtag">*<a name="gp">gp</a>*</b>
["x]gp			Just like "p", but leave the cursor just after the new
			text.

							<b class="vimtag">*<a name="gP">gP</a>*</b>
["x]gP			Just like "P", but leave the cursor just after the new
			text.

							<b class="vimtag">*<a name=":pu">:pu</a>*</b> <b class="vimtag">*<a name=":put">:put</a>*</b>
:<code class="special">[line]</code>pu[t] [x]	Put the text [from register x] after <code class="special">[line]</code> (default
			current line).  This always works |<a href="motion.html#linewise">linewise</a>|, thus
			this command can be used to put a yanked block as new
			lines.
			If no register is specified, it depends on the 'cb'
			option: If 'cb' contains "unnamedplus", paste from the
			+ register |<a href="gui_x11.html#quoteplus">quoteplus</a>|.  Otherwise, if 'cb' contains
			"unnamed", paste from the * register |<a href="gui.html#quotestar">quotestar</a>|.
			Otherwise, paste from the unnamed register
			|<a href="change.html#quote_quote">quote_quote</a>|.
			The register can also be '=' followed by an optional
			expression.  The expression continues until the end of
			the command.  You need to escape the '|' and '"'
			characters to prevent them from terminating the
			command.  Example:
<code class="example">				:put ='path' . \",/test\"</code>
			If there is no expression after '=', Vim uses the
			previous expression.  You can see it with ":dis =".

:<code class="special">[line]</code>pu[t]! [x]	Put the text [from register x] before <code class="special">[line]</code> (default
			current line).

["x]]p		    or					<b class="vimtag">*<a name="]p">]p</a>*</b> <b class="vimtag">*<a name="]%3CMiddleMouse%3E">]&lt;MiddleMouse&gt;</a>*</b>
["x]]<code class="special">&lt;MiddleMouse&gt;</code>	Like "p", but adjust the indent to the current line.
			Using the mouse only works when 'mouse' contains 'n'
			or 'a'.

["x][P		    or					<b class="vimtag">*<a name="[P">[P</a>*</b>
["x]]P		    or					<b class="vimtag">*<a name="]P">]P</a>*</b>
["x][p		    or					<b class="vimtag">*<a name="[p">[p</a>*</b> <b class="vimtag">*<a name="[%3CMiddleMouse%3E">[&lt;MiddleMouse&gt;</a>*</b>
["x][<code class="special">&lt;MiddleMouse&gt;</code>	Like "P", but adjust the indent to the current line.
			Using the mouse only works when 'mouse' contains 'n'
			or 'a'.

You can use these commands to copy text from one place to another.  Do this
by first getting the text into a register with a yank, delete or change
command, then inserting the register contents with a put command.  You can
also use these commands to move text from one file to another, because Vim
preserves all registers when changing buffers (the CTRL-^ command is a quick
way to toggle between two files).

				<b class="vimtag">*<a name="linewise-register">linewise-register</a>*</b> <b class="vimtag">*<a name="characterwise-register">characterwise-register</a>*</b>
You can repeat the put commands with "." (except for :put) and undo them.  If
the command that was used to get the text into the register was |<a href="motion.html#linewise">linewise</a>|,
Vim inserts the text below ("p") or above ("P") the line where the cursor is.
Otherwise Vim inserts the text after ("p") or before ("P") the cursor.  With
the ":put" command, Vim always inserts the text in the next line.  You can
exchange two characters with the command sequence "xp".  You can exchange two
lines with the command sequence "ddp".  You can exchange two words with the
command sequence "deep" (start with the cursor in the blank space before the
first word).  You can use the "']" or "`]" command after the put command to
move the cursor to the end of the inserted text, or use "'[" or "`[" to move
the cursor to the start.

						<b class="vimtag">*<a name="put-Visual-mode">put-Visual-mode</a>*</b> <b class="vimtag">*<a name="v_p">v_p</a>*</b> <b class="vimtag">*<a name="v_P">v_P</a>*</b>
When using a put command like |<a href="change.html#p">p</a>| or |<a href="change.html#P">P</a>| in Visual mode, Vim will try to
replace the selected text with the contents of the register.  Whether this
works well depends on the type of selection and the type of the text in the
register.  With blockwise selection it also depends on the size of the block
and whether the corners are on an existing character.  (Implementation detail:
it actually works by first putting the register after the selection and then
deleting the selection.)
The previously selected text is put in the unnamed register.  If you want to
put the same text into a Visual selection several times you need to use
another register.  E.g., yank the text to copy, Visually select the text to
replace and use "0p .  You can repeat this as many times as you like, the
unnamed register will be changed each time.

When you use a blockwise Visual mode command and yank only a single line into
a register, a paste on a visual selected area will paste that single line on
each of the selected lines (thus replacing the blockwise selected region by a
block of the pasted line).

							<b class="vimtag">*<a name="blockwise-register">blockwise-register</a>*</b>
If you use a blockwise Visual mode command to get the text into the register,
the block of text will be inserted before ("P") or after ("p") the cursor
column in the current and next lines.  Vim makes the whole block of text start
in the same column.  Thus the inserted text looks the same as when it was
yanked or deleted.  Vim may replace some <code class="special">&lt;Tab&gt;</code> characters with spaces to make
this happen.  However, if the width of the block is not a multiple of a <code class="special">&lt;Tab&gt;</code>
width and the text after the inserted block contains <code class="special">&lt;Tab&gt;</code>s, that text may be
misaligned.

<code class="note">Note</code> that after a characterwise yank command, Vim leaves the cursor on the
first yanked character that is closest to the start of the buffer.  This means
that "yl" doesn't move the cursor, but "yh" moves the cursor one character
left.
Rationale:	In Vi the "y" command followed by a backwards motion would
		sometimes not move the cursor to the first yanked character,
		because redisplaying was skipped.  In Vim it always moves to
		the first character, as specified by Posix.
With a linewise yank command the cursor is put in the first line, but the
column is unmodified, thus it may not be on the first yanked character.

There are ten types of registers:		<b class="vimtag">*<a name="registers">registers</a>*</b> <b class="vimtag">*<a name="{register}">{register}</a>*</b> <b class="vimtag">*<a name="E354">E354</a>*</b>
1. The unnamed register ""
2. 10 numbered registers "0 to "9
3. The small delete register "-
4. 26 named registers "a to "z or "A to "Z
5. Three read-only registers ":, "., "%
6. Alternate buffer register "#
7. The expression register "=
<code class="section">8. The selection and drop registers "*, "+ and "</code>
9. The black hole register "_
10. Last search pattern register "/

1. Unnamed register ""				<b class="vimtag">*<a name="quote_quote">quote_quote</a>*</b> <b class="vimtag">*<a name="quotequote">quotequote</a>*</b>
Vim fills this register with text deleted with the "d", "c", "s", "x" commands
or copied with the yank "y" command, regardless of whether or not a specific
register was used (e.g.  "xdd).  This is like the unnamed register is pointing
to the last used register.  Thus when appending using an uppercase register
name, the unnamed register contains the same text as the named register.
An exception is the '_' register: "_dd does not store the deleted text in any
register.
Vim uses the contents of the unnamed register for any put command (p or P)
which does not specify a register.  Additionally you can access it with the
name '"'.  This means you have to type two double quotes.  Writing to the ""
register writes to register "0.
<code class="special">{Vi: register contents are lost when changing files, no '"'}</code>

2. Numbered registers "0 to "9		<b class="vimtag">*<a name="quote_number">quote_number</a>*</b> <b class="vimtag">*<a name="quote0">quote0</a>*</b> <b class="vimtag">*<a name="quote1">quote1</a>*</b>
					<b class="vimtag">*<a name="quote2">quote2</a>*</b> <b class="vimtag">*<a name="quote3">quote3</a>*</b> <b class="vimtag">*<a name="quote4">quote4</a>*</b> <b class="vimtag">*<a name="quote9">quote9</a>*</b>
Vim fills these registers with text from yank and delete commands.
   Numbered register 0 contains the text from the most recent yank command,
unless the command specified another register with ["x].
   Numbered register 1 contains the text deleted by the most recent delete or
change command, unless the command specified another register or the text is
less than one line (the small delete register is used then).  An exception is
made for the delete operator with these movement commands: |<a href="motion.html#%">%</a>|, |<a href="motion.html#(">(</a>|, |<a href="motion.html#)">)</a>|, |<a href="motion.html#`">`</a>|,
|<a href="pattern.html#%2F">/</a>|, |<a href="pattern.html#?">?</a>|, |<a href="pattern.html#n">n</a>|, |<a href="pattern.html#N">N</a>|, |<a href="motion.html#{">{</a>| and |<a href="motion.html#}">}</a>|.  Register "1 is always used then (this is Vi
compatible).  The "- register is used as well if the delete is within a line.
<code class="note">Note</code> that these characters may be mapped.  E.g. |<a href="motion.html#%">%</a>| is mapped by the matchit
plugin.
   With each successive deletion or change, Vim shifts the previous contents
of register 1 into register 2, 2 into 3, and so forth, losing the previous
contents of register 9.
{Vi: numbered register contents are lost when changing files; register 0 does
not exist}

3. Small delete register "-				<b class="vimtag">*<a name="quote_-">quote_-</a>*</b> <b class="vimtag">*<a name="quote-">quote-</a>*</b>
This register contains text from commands that delete less than one line,
except when the command specifies a register with ["x].

4. Named registers "a to "z or "A to "Z			<b class="vimtag">*<a name="quote_alpha">quote_alpha</a>*</b> <b class="vimtag">*<a name="quotea">quotea</a>*</b>
Vim fills these registers only when you say so.  Specify them as lowercase
letters to replace their previous contents or as uppercase letters to append
to their previous contents.  When the '&gt;' flag is present in 'cpoptions' then
a line break is inserted before the appended text.

5. Read-only registers ":, ". and "%
These are '%', '#', ':' and '.'.  You can use them only with the "p", "P",
and ":put" commands and with <code class="keystroke">CTRL-R</code>.
						<b class="vimtag">*<a name="quote_.">quote_.</a>*</b> <b class="vimtag">*<a name="quote.">quote.</a>*</b> <b class="vimtag">*<a name="E29">E29</a>*</b>
	".	Contains the last inserted text (the same as what is inserted
		with the insert mode commands <code class="keystroke">CTRL-A</code> and CTRL-@).  <code class="note">Note:</code> this
		doesn't work with <code class="keystroke">CTRL-R</code> on the command-line.  It works a bit
		differently, like inserting the text instead of putting it
		('textwidth' and other options affect what is inserted).
							<b class="vimtag">*<a name="quote_%">quote_%</a>*</b> <b class="vimtag">*<a name="quote%">quote%</a>*</b>
	"%	Contains the name of the current file.
						<b class="vimtag">*<a name="quote_:">quote_:</a>*</b> <b class="vimtag">*<a name="quote:">quote:</a>*</b> <b class="vimtag">*<a name="E30">E30</a>*</b>
	":	Contains the most recent executed command-line.  Example: Use
		"@:" to repeat the previous command-line command.
		The command-line is only stored in this register when at least
		one character of it was typed.  Thus it remains unchanged if
		the command was completely from a mapping.
		{not available when compiled without the |<a href="various.html#+cmdline_hist">+cmdline_hist</a>|
		feature}
							<b class="vimtag">*<a name="quote_%23">quote_#</a>*</b> <b class="vimtag">*<a name="quote%23">quote#</a>*</b>
6. Alternate file register "#
Contains the name of the alternate file for the current window.  It will
change how the |<a href="editing.html#CTRL-^">CTRL-^</a>| command works.
This register is writable, mainly to allow for restoring it after a plugin has
changed it.  It accepts buffer number:
<code class="example">    let altbuf = bufnr(@#)</code>
<code class="example">    ...</code>
<code class="example">    let @# = altbuf</code>
It will give error |<a href="windows.html#E86">E86</a>| if you pass buffer number and this buffer does not
exist.
It can also accept a match with an existing buffer name:
<code class="example">    let @# = 'buffer_name'</code>
Error |<a href="windows.html#E93">E93</a>| if there is more than one buffer matching the given name or |<a href="windows.html#E94">E94</a>|
if none of buffers matches the given name.

7. Expression register "=			<b class="vimtag">*<a name="quote_%20">quote_=</a>*</b> <b class="vimtag">*<a name="quote%20">quote=</a>*</b> <b class="vimtag">*<a name="@%20">@=</a>*</b>
This is not really a register that stores text, but is a way to use an
expression in commands which use a register.  The expression register is
read-write.

When typing the '=' after " or <code class="keystroke">CTRL-R</code> the cursor moves to the command-line,
where you can enter any expression (see |<a href="eval.html#expression">expression</a>|).  All normal
command-line editing commands are available, including a special history for
expressions.  When you end the command-line by typing <code class="special">&lt;CR&gt;</code>, Vim computes the
result of the expression.  If you end it with <code class="special">&lt;Esc&gt;</code>, Vim abandons the
expression.  If you do not enter an expression, Vim uses the previous
expression (like with the "/" command).

The expression must evaluate to a String.  A Number is always automatically
converted to a String.  For the "p" and ":put" command, if the result is a
Float it's converted into a String.  If the result is a List each element is
turned into a String and used as a line.  A Dictionary or FuncRef results in
an error message (use string() to convert).

If the "= register is used for the "p" command, the String is split up at <code class="special">&lt;NL&gt;</code>
characters.  If the String ends in a <code class="special">&lt;NL&gt;</code>, it is regarded as a linewise
register.

<code class="section">8. Selection and drop registers "*, "+ and "</code>
Use these registers for storing and retrieving the selected text for the GUI.
See |<a href="gui.html#quotestar">quotestar</a>| and |<a href="gui_x11.html#quoteplus">quoteplus</a>|.  When the clipboard is not available or not
working, the unnamed register is used instead.  For Unix systems the clipboard
is only available when the |<a href="various.html#+xterm_clipboard">+xterm_clipboard</a>| feature is present.

<code class="note">Note</code> that there is only a distinction between "* and "+ for X11 systems.  For
an explanation of the difference, see |<a href="gui_x11.html#x11-selection">x11-selection</a>|.  Under MS-Windows, use
of "* and "+ is actually synonymous and refers to the |<a href="gui_w32.html#gui-clipboard">gui-clipboard</a>|.

						<b class="vimtag">*<a name="quote_%7E">quote_~</a>*</b> <b class="vimtag">*<a name="quote%7E">quote~</a>*</b> <b class="vimtag">*<a name="%3CDrop%3E">&lt;Drop&gt;</a>*</b>
The read-only "~ register stores the dropped text from the last drag'n'drop
operation.  When something has been dropped onto Vim, the "~ register is
filled in and the <code class="special">&lt;Drop&gt;</code> pseudo key is sent for notification.  You can remap
this key if you want; the default action (for all modes) is to insert the
contents of the "~ register at the cursor position.
{only available when compiled with the |<a href="various.html#+dnd">+dnd</a>| feature, currently only with the
GTK GUI}

<code class="note">Note:</code> The "~ register is only used when dropping plain text onto Vim.
Drag'n'drop of URI lists is handled internally.

9. Black hole register "_				<b class="vimtag">*<a name="quote_">quote_</a>*</b>
When writing to this register, nothing happens.  This can be used to delete
text without affecting the normal registers.  When reading from this register,
nothing is returned.

10. Last search pattern register	"/		<b class="vimtag">*<a name="quote_%2F">quote_/</a>*</b> <b class="vimtag">*<a name="quote%2F">quote/</a>*</b>
Contains the most recent search-pattern.  This is used for "n" and 'hlsearch'.
It is writable with `:let`, you can change it to have 'hlsearch' highlight
other matches without actually searching.  You can't yank or delete into this
register.  The search direction is available in |<a href="eval.html#v:searchforward">v:searchforward</a>|.
<code class="note">Note</code> that the value is restored when returning from a function
|<a href="eval.html#function-search-undo">function-search-undo</a>|.

							<b class="vimtag">*<a name="@%2F">@/</a>*</b>
You can write to a register with a `:let` command |<a href="eval.html#:let-@">:let-@</a>|.  Example:
<code class="example">	:let @/ = "the"</code>
<code class="example"></code>
If you use a put command without specifying a register, Vim uses the register
that was last filled (this is also the contents of the unnamed register).  If
you are confused, use the `:dis` command to find out what Vim will put (this
command displays all named and numbered registers; the unnamed register is
labelled '"').

The next three commands always work on whole lines.

:<code class="special">[range]</code>co[py] <code class="special">{address}</code>				<b class="vimtag">*<a name=":co">:co</a>*</b> <b class="vimtag">*<a name=":copy">:copy</a>*</b>
			Copy the lines given by <code class="special">[range]</code> to below the line
			given by <code class="special">{address}</code>.

							<b class="vimtag">*<a name=":t">:t</a>*</b>
:t			Synonym for copy.

:<code class="special">[range]</code>m[ove] <code class="special">{address}</code>			<b class="vimtag">*<a name=":m">:m</a>*</b> <b class="vimtag">*<a name=":mo">:mo</a>*</b> <b class="vimtag">*<a name=":move">:move</a>*</b> <b class="vimtag">*<a name="E134">E134</a>*</b>
			Move the lines given by <code class="special">[range]</code> to below the line
			given by <code class="special">{address}</code>.

</pre><hr/><pre>6. Formatting text					<b class="vimtag">*<a name="formatting">formatting</a>*</b>

:<code class="special">[range]</code>ce[nter] [width]				<b class="vimtag">*<a name=":ce">:ce</a>*</b> <b class="vimtag">*<a name=":center">:center</a>*</b>
			Center lines in <code class="special">[range]</code> between [width] columns
			(default 'textwidth' or 80 when 'textwidth' is 0).

:<code class="special">[range]</code>ri[ght] [width]					<b class="vimtag">*<a name=":ri">:ri</a>*</b> <b class="vimtag">*<a name=":right">:right</a>*</b>
			Right-align lines in <code class="special">[range]</code> at [width] columns
			(default 'textwidth' or 80 when 'textwidth' is 0).

							<b class="vimtag">*<a name=":le">:le</a>*</b> <b class="vimtag">*<a name=":left">:left</a>*</b>
:<code class="special">[range]</code>le[ft] [indent]
			Left-align lines in <code class="special">[range]</code>.  Sets the indent in the
			lines to [indent] (default 0).

							<b class="vimtag">*<a name="gq">gq</a>*</b>
gq<code class="special">{motion}</code>		Format the lines that <code class="special">{motion}</code> moves over.
			Formatting is done with one of three methods:
			1. If 'formatexpr' is not empty the expression is
			   evaluated.  This can differ for each buffer.
			2. If 'formatprg' is not empty an external program
			   is used.
			3. Otherwise formatting is done internally.

			In the third case the 'textwidth' option controls the
			length of each formatted line (see below).
			If the 'textwidth' option is 0, the formatted line
			length is the screen width (with a maximum width of
			79).
			The 'formatoptions' option controls the type of
			formatting |<a href="change.html#fo-table">fo-table</a>|.
			The cursor is left on the first non-blank of the last
			formatted line.
			<code class="note">NOTE:</code> The "Q" command formerly performed this
			function.  If you still want to use "Q" for
			formatting, use this mapping:
<code class="example">				:nnoremap Q gq</code>
<code class="example"></code>
gqgq							<b class="vimtag">*<a name="gqgq">gqgq</a>*</b> <b class="vimtag">*<a name="gqq">gqq</a>*</b>
gqq			Format the current line.  With a count format that
			many lines.

							<b class="vimtag">*<a name="v_gq">v_gq</a>*</b>
<code class="special">{Visual}</code>gq		Format the highlighted text.  (for <code class="special">{Visual}</code> see
			|<a href="visual.html#Visual-mode">Visual-mode</a>|).

							<b class="vimtag">*<a name="gw">gw</a>*</b>
gw<code class="special">{motion}</code>		Format the lines that <code class="special">{motion}</code> moves over.  Similar to
			|<a href="change.html#gq">gq</a>| but puts the cursor back at the same position in
			the text.  However, 'formatprg' and 'formatexpr' are
			not used.

gwgw							<b class="vimtag">*<a name="gwgw">gwgw</a>*</b> <b class="vimtag">*<a name="gww">gww</a>*</b>
gww			Format the current line as with "gw".

							<b class="vimtag">*<a name="v_gw">v_gw</a>*</b>
<code class="special">{Visual}</code>gw		Format the highlighted text as with "gw".  (for
			<code class="special">{Visual}</code> see |<a href="visual.html#Visual-mode">Visual-mode</a>|).

Example: To format the current paragraph use:			<b class="vimtag">*<a name="gqap">gqap</a>*</b>
<code class="example">	gqap</code>
<code class="example"></code>
The "gq" command leaves the cursor in the line where the motion command takes
the cursor.  This allows you to repeat formatting repeated with ".".  This
works well with "gqj" (format current and next line) and "gq}" (format until
end of paragraph).  <code class="note">Note:</code> When 'formatprg' is set, "gq" leaves the cursor on
the first formatted line (as with using a filter command).

If you want to format the current paragraph and continue where you were, use:
<code class="example">	gwap</code>
If you always want to keep paragraphs formatted you may want to add the 'a'
flag to 'formatoptions'.  See |<a href="change.html#auto-format">auto-format</a>|.

If the 'autoindent' option is on, Vim uses the indent of the first line for
the following lines.

Formatting does not change empty lines (but it does change lines with only
white space!).

The 'joinspaces' option is used when lines are joined together.

You can set the 'formatexpr' option to an expression or the 'formatprg' option
to the name of an external program for Vim to use for text formatting.  The
'textwidth' and other options have no effect on formatting by an external
program.

                                                        <b class="vimtag">*<a name="format-formatexpr">format-formatexpr</a>*</b>
The 'formatexpr' option can be set to a Vim script function that performs
reformatting of the buffer.  This should usually happen in an |<a href="usr_41.html#ftplugin">ftplugin</a>|,
since formatting is highly dependent on the type of file.  It makes
sense to use an |<a href="eval.html#autoload">autoload</a>| script, so the corresponding script is only loaded
when actually needed and the script should be called <code class="special">&lt;filetype&gt;</code>format.vim.

For example, the XML filetype plugin distributed with Vim in the $VIMRUNTIME
directory, sets the 'formatexpr' option to:
<code class="example"></code>
<code class="example">   setlocal formatexpr=xmlformat#Format()</code>
<code class="example"></code>
That means, you will find the corresponding script, defining the
xmlformat#Format() function, in the directory:
`$VIMRUNTIME/autoload/xmlformat.vim`

Here is an example script that removes trailing whitespace from the selected
text.  Put it in your autoload directory, e.g. ~/.vim/autoload/format.vim:
<code class="example"></code>
<code class="example">  func! format#Format()</code>
<code class="example">    " only reformat on explicit gq command</code>
<code class="example">    if mode() != 'n'</code>
<code class="example">      " fall back to Vims internal reformatting</code>
<code class="example">      return 1</code>
<code class="example">    endif</code>
<code class="example">    let lines = getline(v:lnum, v:lnum + v:count - 1)</code>
<code class="example">    call map(lines, <code class="special">{key, val -&gt; substitute(val, '\s\+$', '', 'g')}</code>)</code>
<code class="example">    call setline('.', lines)</code>
<code class="example"></code>
<code class="example">    " do not run internal formatter!</code>
<code class="example">    return 0</code>
<code class="example">  endfunc</code>
<code class="example"></code>
You can then enable the formatting by executing:
<code class="example">  setlocal formatexpr=format#Format()</code>
<code class="example"></code>
<code class="note">Note:</code> this function explicitly returns non-zero when called from insert mode
(which basically means, text is inserted beyond the 'textwidth' limit).  This
causes Vim to fall back to reformat the text by using the internal formatter.

However, if the |<a href="change.html#gq">gq</a>| command is used to reformat the text, the function
will receive the selected lines, trim trailing whitespace from those lines and
put them back in place.  If you are going to split single lines into multiple
lines, be careful not to overwrite anything.

If you want to allow reformatting of text from insert or replace mode, one has
to be very careful, because the function might be called recursively.  For
debugging it helps to set the 'debug' option.

							<b class="vimtag">*<a name="right-justify">right-justify</a>*</b>
There is no command in Vim to right justify text.  You can do it with
an external command, like "par" (e.g.: "!}par" to format until the end of the
paragraph) or set 'formatprg' to "par".

							<b class="vimtag">*<a name="format-comments">format-comments</a>*</b>
An overview of comment formatting is in section |<a href="usr_30.html#30.6">30.6</a>| of the user manual.

Vim can automatically insert and format comments in a special way.  Vim
recognizes a comment by a specific string at the start of the line (ignoring
white space).  Three types of comments can be used:

- A comment string that repeats at the start of each line.  An example is the
  type of comment used in shell scripts, starting with "#".
- A comment string that occurs only in the first line, not in the following
  lines.  An example is this list with dashes.
- Three-piece comments that have a start string, an end string, and optional
  lines in between.  The strings for the start, middle and end are different.
  An example is the C style comment:
	/*
	 * this is a C comment
	 */

The 'comments' option is a comma-separated list of parts.  Each part defines a
type of comment string.  A part consists of:
	<code class="special">{flags}</code>:<code class="special">{string}</code>

<code class="special">{string}</code> is the literal text that must appear.

<code class="special">{flags}</code>:
  n	Nested comment.  Nesting with mixed parts is allowed.  If 'comments'
	is "n:),n:&gt;" a line starting with "&gt; ) &gt;" is a comment.

  b	Blank (<code class="special">&lt;Space&gt;</code>, <code class="special">&lt;Tab&gt;</code> or <code class="special">&lt;EOL&gt;</code>) required after <code class="special">{string}</code>.

  f	Only the first line has the comment string.  Do not repeat comment on
	the next line, but preserve indentation (e.g., a bullet-list).

  s	Start of three-piece comment

  m	Middle of a three-piece comment

  e	End of a three-piece comment

  l	Left align. Used together with 's' or 'e', the leftmost character of
	start or end will line up with the leftmost character from the middle.
	This is the default and can be omitted. See below for more details.

  r	Right align. Same as above but rightmost instead of leftmost. See
	below for more details.

  O	Don't consider this comment for the "O" command.

  x	Allows three-piece comments to be ended by just typing the last
	character of the end-comment string as the first action on a new
	line when the middle-comment string has been inserted automatically.
	See below for more details.

  <code class="special">{digits}</code>
	When together with 's' or 'e': add <code class="special">{digit}</code> amount of offset to an
	automatically inserted middle or end comment leader. The offset begins
	from a left alignment. See below for more details.

  -<code class="special">{digits}</code>
	Like <code class="special">{digits}</code> but reduce the indent.  This only works when there is
	some indent for the start or end part that can be removed.

When a string has none of the 'f', 's', 'm' or 'e' flags, Vim assumes the
comment string repeats at the start of each line.  The flags field may be
empty.

Any blank space in the text before and after the <code class="special">{string}</code> is part of the
<code class="special">{string}</code>, so do not include leading or trailing blanks unless the blanks are a
required part of the comment string.

When one comment leader is part of another, specify the part after the whole.
For example, to include both "-" and "-&gt;", use
<code class="example">	:set comments=f:-&gt;,f:-</code>
<code class="example"></code>
A three-piece comment must always be given as start,middle,end, with no other
parts in between.  An example of a three-piece comment is
<code class="example">	sr:/<b class="vimtag">*<a name=",mb:">,mb:</a>*</b>,ex:*/</code>
for C-comments.  To avoid recognizing "*ptr" as a comment, the middle string
includes the 'b' flag.  For three-piece comments, Vim checks the text after
the start and middle strings for the end string.  If Vim finds the end string,
the comment does not continue on the next line.  Three-piece comments must
have a middle string because otherwise Vim can't recognize the middle lines.

Notice the use of the "x" flag in the above three-piece comment definition.
When you hit Return in a C-comment, Vim will insert the middle comment leader
for the new line: " * ".  To close this comment you just have to type "/"
before typing anything else on the new line.  This will replace the
middle-comment leader with the end-comment leader and apply any specified
alignment, leaving just " */".  There is no need to hit Backspace first.

When there is a match with a middle part, but there also is a matching end
part which is longer, the end part is used.  This makes a C style comment work
without requiring the middle part to end with a space.

Here is an example of alignment flags at work to make a comment stand out
(kind of looks like a 1 too). Consider comment string:
<code class="example">	:set comments=sr:/**<b class="vimtag">*<a name=",m:">,m:</a>*</b><b class="vimtag">*<a name=",ex-2:">,ex-2:</a>*</b>*****/</code>

<code class="section">                                   /*** </code>
<code class="section">                                     **&lt;--right aligned from "r" flag </code>
<code class="section">                                     ** </code>
<code class="section">offset 2 spaces for the "-2" flag---&gt;** </code>
<code class="section">                                   ******/ </code>
In this case, the first comment was typed, then return was pressed 4 times,
then "/" was pressed to end the comment.

Here are some finer points of three part comments. There are three times when
alignment and offset flags are taken into consideration: opening a new line
after a start-comment, opening a new line before an end-comment, and
automatically ending a three-piece comment.  The end alignment flag has a
backwards perspective; the result is that the same alignment flag used with
"s" and "e" will result in the same indent for the starting and ending pieces.
Only one alignment per comment part is meant to be used, but an offset number
will override the "r" and "l" flag.

Enabling 'cindent' will override the alignment flags in many cases.
Reindenting using a different method like |<a href="change.html#gq">gq</a>| or |<a href="change.html#%20">=</a>| will not consult
alignment flags either. The same behaviour can be defined in those other
formatting options. One consideration is that 'cindent' has additional options
for context based indenting of comments but cannot replicate many three piece
indent alignments.  However, 'indentexpr' has the ability to work better with
three piece comments.

Other examples:
<code class="example">   "b:<b class="vimtag">*<a name="%22	Includes lines starting with %22">"	Includes lines starting with "</a>*</b>", but not if the "*" is</code>
<code class="example">		followed by a non-blank.  This avoids a pointer dereference</code>
<code class="example">		like "*str" to be recognized as a comment.</code>
<code class="example">   "n:&gt;"	Includes a line starting with "&gt;", "&gt;&gt;", "&gt;&gt;&gt;", etc.</code>
<code class="example">   "fb:-"	Format a list that starts with "- ".</code>
<code class="example"></code>
By default, "b:#" is included.  This means that a line that starts with
"#include" is not recognized as a comment line.  But a line that starts with
"# define" is recognized.  This is a compromise.

							<b class="vimtag">*<a name="fo-table">fo-table</a>*</b>
You can use the 'formatoptions' option  to influence how Vim formats text.
'formatoptions' is a string that can contain any of the letters below.  The
default setting is "tcq".  You can separate the option letters with commas for
readability.

<code class="section">letter	 meaning when present in 'formatoptions'    </code>

t	Auto-wrap text using textwidth
c	Auto-wrap comments using textwidth, inserting the current comment
	leader automatically.
r	Automatically insert the current comment leader after hitting
	<code class="special">&lt;Enter&gt;</code> in Insert mode.
o	Automatically insert the current comment leader after hitting 'o' or
	'O' in Normal mode.
q	Allow formatting of comments with "gq".
	<code class="note">Note</code> that formatting will not change blank lines or lines containing
	only the comment leader.  A new paragraph starts after such a line,
	or when the comment leader changes.
w	Trailing white space indicates a paragraph continues in the next line.
	A line that ends in a non-white character ends a paragraph.
a	Automatic formatting of paragraphs.  Every time text is inserted or
	deleted the paragraph will be reformatted.  See |<a href="change.html#auto-format">auto-format</a>|.
	When the 'c' flag is present this only happens for recognized
	comments.
n	When formatting text, recognize numbered lists.  This actually uses
	the 'formatlistpat' option, thus any kind of list can be used.  The
	indent of the text after the number is used for the next line.  The
	default is to find a number, optionally followed by '.', ':', ')',
	']' or '}'.  <code class="note">Note</code> that 'autoindent' must be set too.  Doesn't work
	well together with "2".
	Example:
<code class="example">		1. the first item</code>
<code class="example">		   wraps</code>
<code class="example">		2. the second item</code>
2	When formatting text, use the indent of the second line of a paragraph
	for the rest of the paragraph, instead of the indent of the first
	line.  This supports paragraphs in which the first line has a
	different indent than the rest.  <code class="note">Note</code> that 'autoindent' must be set
	too.  Example:
<code class="example">			first line of a paragraph</code>
<code class="example">		second line of the same paragraph</code>
<code class="example">		third line.</code>
	This also works inside comments, ignoring the comment leader.
v	Vi-compatible auto-wrapping in insert mode: Only break a line at a
	blank that you have entered during the current insert command.  (<code class="note">Note:</code>
	this is not 100% Vi compatible.  Vi has some "unexpected features" or
	bugs in this area.  It uses the screen column instead of the line
	column.)
b	Like 'v', but only auto-wrap if you enter a blank at or before
	the wrap margin.  If the line was longer than 'textwidth' when you
	started the insert, or you do not enter a blank in the insert before
	reaching 'textwidth', Vim does not perform auto-wrapping.
l	Long lines are not broken in insert mode: When a line was longer than
	'textwidth' when the insert command started, Vim does not
	automatically format it.
m	Also break at a multi-byte character above 255.  This is useful for
	Asian text where every character is a word on its own.
M	When joining lines, don't insert a space before or after a multi-byte
	character.  Overrules the 'B' flag.
B	When joining lines, don't insert a space between two multi-byte
	characters.  Overruled by the 'M' flag.
1	Don't break a line after a one-letter word.  It's broken before it
	instead (if possible).
j	Where it makes sense, remove a comment leader when joining lines.  For
	example, joining:
<code class="section">		int i;   // the index </code>
<code class="section">		         // in the list </code>
	Becomes:
<code class="section">		int i;   // the index in the list </code>
p	Don't break lines at single spaces that follow periods.  This is
	intended to complement 'joinspaces' and |<a href="options.html#cpo-J">cpo-J</a>|, for prose with
	sentences separated by two spaces.  For example, with 'textwidth' set
	to 28:
<code class="example">		Surely you're joking, Mr. Feynman!</code>
&lt;	Becomes:
<code class="example">		Surely you're joking,</code>
<code class="example">		Mr. Feynman!</code>
&lt;	Instead of:
<code class="example">		Surely you're joking, Mr.</code>
<code class="example">		Feynman!</code>
<code class="example"></code>
<code class="example"></code>
With 't' and 'c' you can specify when Vim performs auto-wrapping:
<code class="section">value	action	</code>
""	no automatic formatting (you can use "gq" for manual formatting)
"t"	automatic formatting of text, but not comments
"c"	automatic formatting for comments, but not text (good for C code)
"tc"	automatic formatting for text and comments

<code class="note">Note</code> that when 'textwidth' is 0, Vim does no automatic formatting anyway (but
does insert comment leaders according to the 'comments' option).  An exception
is when the 'a' flag is present. |<a href="change.html#auto-format">auto-format</a>|

<code class="note">Note</code> that when 'paste' is on, Vim does no formatting at all.

<code class="note">Note</code> that 'textwidth' can be non-zero even if Vim never performs auto-wrapping;
'textwidth' is still useful for formatting with "gq".

If the 'comments' option includes "/<b class="vimtag">*<a name="%22, %22">", "</a>*</b>" and/or "*/", then Vim has some
built in stuff to treat these types of comments a bit more cleverly.
Opening a new line before or after "/<b class="vimtag">*<a name="%22 or %22">" or "</a>*</b>/" (with 'r' or 'o' present in
'formatoptions') gives the correct start of the line automatically.  The same
happens with formatting and auto-wrapping.  Opening a line after a line
starting with "/<b class="vimtag">*<a name="%22 or %22">" or "</a>*</b>" and containing "*/", will cause no comment leader to
be inserted, and the indent of the new line is taken from the line containing
the start of the comment.
E.g.:
<code class="section">    /* </code>
<code class="section">     * Your typical comment. </code>
<code class="section">     */ </code>
    The indent on this line is the same as the start of the above
    comment.

All of this should be really cool, especially in conjunction with the new
:autocmd command to prepare different settings for different types of file.

Some examples:
  for C code (only format comments):
<code class="example">	:set fo=croq</code>
&lt; for Mail/news	(format all, don't start comment with "o" command):
<code class="example">	:set fo=tcrq</code>


Automatic formatting				<b class="vimtag">*<a name="auto-format">auto-format</a>*</b> <b class="vimtag">*<a name="autoformat">autoformat</a>*</b>

When the 'a' flag is present in 'formatoptions' text is formatted
automatically when inserting text or deleting text.  This works nice for
editing text paragraphs.  A few hints on how to use this:

- You need to properly define paragraphs.  The simplest is paragraphs that are
  separated by a blank line.  When there is no separating blank line, consider
  using the 'w' flag and adding a space at the end of each line in the
  paragraphs except the last one.

- You can set the 'formatoptions' based on the type of file |<a href="filetype.html#filetype">filetype</a>| or
  specifically for one file with a |<a href="options.html#modeline">modeline</a>|.

- Set 'formatoptions' to "aw2tq" to make text with indents like this:

	    bla bla foobar bla
	bla foobar bla foobar bla
	    bla bla foobar bla
	bla foobar bla bla foobar

- Add the 'c' flag to only auto-format comments.  Useful in source code.

- Set 'textwidth' to the desired width.  If it is zero then 79 is used, or the
  width of the screen if this is smaller.

And a few warnings:

- When part of the text is not properly separated in paragraphs, making
  changes in this text will cause it to be formatted anyway.  Consider doing
<code class="example"></code>
<code class="example">	:set fo-=a</code>
<code class="example"></code>
- When using the 'w' flag (trailing space means paragraph continues) and
  deleting the last line of a paragraph with |<a href="change.html#dd">dd</a>|, the paragraph will be
  joined with the next one.

- Changed text is saved for undo.  Formatting is also a change.  Thus each
  format action saves text for undo.  This may consume quite a lot of memory.

- Formatting a long paragraph and/or with complicated indenting may be slow.

</pre><hr/><pre>7. Sorting text						<b class="vimtag">*<a name="sorting">sorting</a>*</b>

Vim has a sorting function and a sorting command.  The sorting function can be
found here: |<a href="eval.html#sort()">sort()</a>|, |<a href="eval.html#uniq()">uniq()</a>|.

							<b class="vimtag">*<a name=":sor">:sor</a>*</b> <b class="vimtag">*<a name=":sort">:sort</a>*</b>
:<code class="special">[range]</code>sor[t][!] [b][f][i][n][o][r][u][x] [/<code class="special">{pattern}</code>/]
			Sort lines in <code class="special">[range]</code>.  When no range is given all
			lines are sorted.

			With [!] the order is reversed.

			With [i] case is ignored.

			Options [n][f][x][o][b] are mutually exclusive.

			With [n] sorting is done on the first decimal number
			in the line (after or inside a <code class="special">{pattern}</code> match).
			One leading '-' is included in the number.

			With [f] sorting is done on the Float in the line.
			The value of Float is determined similar to passing
			the text (after or inside a <code class="special">{pattern}</code> match) to
			str2float() function. This option is available only
			if Vim was compiled with Floating point support.

			With [x] sorting is done on the first hexadecimal
			number in the line (after or inside a <code class="special">{pattern}</code>
			match).  A leading "0x" or "0X" is ignored.
			One leading '-' is included in the number.

			With [o] sorting is done on the first octal number in
			the line (after or inside a <code class="special">{pattern}</code> match).

			With [b] sorting is done on the first binary number in
			the line (after or inside a <code class="special">{pattern}</code> match).

			With [u] (u stands for unique) only keep the first of
			a sequence of identical lines (ignoring case when [i]
			is used).  Without this flag, a sequence of identical
			lines will be kept in their original order.
			<code class="note">Note</code> that leading and trailing white space may cause
			lines to be different.

			When /<code class="special">{pattern}</code>/ is specified and there is no [r] flag
			the text matched with <code class="special">{pattern}</code> is skipped, so that
			you sort on what comes after the match.
			Instead of the slash any non-letter can be used.
			For example, to sort on the second comma-separated
			field:
<code class="example">				:sort /[^,]*,/</code>
			To sort on the text at virtual column 10 (thus
			ignoring the difference between tabs and spaces):
<code class="example">				:sort /.*\%10v/</code>
			To sort on the first number in the line, no matter
			what is in front of it:
<code class="example">				:sort /.\<code class="special">{-}</code>\ze\d/</code>
			(Explanation: ".\<code class="special">{-}</code>" matches any text, "\ze" sets the
			end of the match and \d matches a digit.)
			With [r] sorting is done on the matching <code class="special">{pattern}</code>
			instead of skipping past it as described above.
			For example, to sort on only the first three letters
			of each line:
<code class="example">				:sort /\a\a\a/ r</code>
<code class="example"></code>
			If a <code class="special">{pattern}</code> is used, any lines which don't have a
			match for <code class="special">{pattern}</code> are kept in their current order,
			but separate from the lines which do match <code class="special">{pattern}</code>.
			If you sorted in reverse, they will be in reverse
			order after the sorted lines, otherwise they will be
			in their original order, right before the sorted
			lines.

			If <code class="special">{pattern}</code> is empty (e.g. // is specified), the
			last search pattern is used.  This allows trying out
			a pattern first.

<code class="note">Note</code> that using `:sort` with `:global` doesn't sort the matching lines, it's
quite useless.

The details about sorting depend on the library function used.  There is no
guarantee that sorting obeys the current locale.  You will have to try it out.
Vim does do a "stable" sort.

The sorting can be interrupted, but if you interrupt it too late in the
process you may end up with duplicated lines.  This also depends on the system
library function used.

 vim:tw=78:ts=8:noet:ft=help:norl:
</pre>
<p><i>Generated by vim2html on Wed Feb 26 03:19:42 UTC 2020</i></p>
</body>
</html>
