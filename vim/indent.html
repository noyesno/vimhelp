<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>VIM: indent</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css"/>
</head>
<body>
<h2>INDENT</h2>
<pre>
<b class="vimtag">*<a name="indent.txt">indent.txt</a>*</b>    For Vim version 8.2.  Last change: 2019 Dec 07


		  VIM REFERENCE MANUAL    by Bram Moolenaar


This file is about indenting C programs and other files.

1. Indenting C style programs	|<a href="indent.html#C-indenting">C-indenting</a>|
2. Indenting by expression	|<a href="indent.html#indent-expression">indent-expression</a>|

</pre><hr/><pre>1. Indenting C style programs				<b class="vimtag">*<a name="C-indenting">C-indenting</a>*</b>

The basics for C style indenting are explained in section |<a href="usr_30.html#30.2">30.2</a>| of the user
manual.

Vim has options for automatically indenting C style program files. Many
programming languages including Java and C++ follow very closely the
formatting conventions established with C.  These options affect only the
indent and do not perform other formatting.  There are additional options that
affect other kinds of formatting as well as indenting, see |<a href="change.html#format-comments">format-comments</a>|,
|<a href="change.html#fo-table">fo-table</a>|, |<a href="change.html#gq">gq</a>| and |<a href="change.html#formatting">formatting</a>| for the main ones.

<code class="note">Note</code> that this will not work when the |<a href="various.html#+smartindent">+smartindent</a>| or |<a href="various.html#+cindent">+cindent</a>| features
have been disabled at compile time.

There are in fact four main methods available for indentation, each one
overrides the previous if it is enabled, or non-empty for 'indentexpr':
'autoindent'	uses the indent from the previous line.
'smartindent'	is like 'autoindent' but also recognizes some C syntax to
		increase/reduce the indent where appropriate.
'cindent'	Works more cleverly than the other two and is configurable to
		different indenting styles.
'indentexpr'	The most flexible of all: Evaluates an expression to compute
		the indent of a line.  When non-empty this method overrides
		the other ones.  See |<a href="indent.html#indent-expression">indent-expression</a>|.
The rest of this section describes the 'cindent' option.

<code class="note">Note</code> that 'cindent' indenting does not work for every code scenario.  Vim
is not a C compiler: it does not recognize all syntax.  One requirement is
that toplevel functions have a '{' in the first column.  Otherwise they are
easily confused with declarations.

These four options control C program indenting:
'cindent'	Enables Vim to perform C program indenting automatically.
'cinkeys'	Specifies which keys trigger reindenting in insert mode.
'cinoptions'	Sets your preferred indent style.
'cinwords'	Defines keywords that start an extra indent in the next line.

If 'lisp' is not on and 'equalprg' is empty, the "=" operator indents using
Vim's built-in algorithm rather than calling an external program.

See |<a href="autocmd.html#autocommand">autocommand</a>| for how to set the 'cindent' option automatically for C code
files and reset it for others.

					<b class="vimtag">*<a name="cinkeys-format">cinkeys-format</a>*</b> <b class="vimtag">*<a name="indentkeys-format">indentkeys-format</a>*</b>
The 'cinkeys' option is a string that controls Vim's indenting in response to
typing certain characters or commands in certain contexts.  <code class="note">Note</code> that this not
only triggers C-indenting.  When 'indentexpr' is not empty 'indentkeys' is
used instead.  The format of 'cinkeys' and 'indentkeys' is equal.

The default is "0<code class="special">{,0}</code>,0),0],:,0#,!^F,o,O,e" which specifies that indenting
occurs as follows:

	"0{"	if you type '{' as the first character in a line
	"0}"	if you type '}' as the first character in a line
	"0)"	if you type ')' as the first character in a line
	"0]"	if you type ']' as the first character in a line
	":"	if you type ':' after a label or case statement
	"0#"	if you type '#' as the first character in a line
	"!^F"	if you type <code class="keystroke">CTRL-F</code> (which is not inserted)
	"o"	if you type a <code class="special">&lt;CR&gt;</code> anywhere or use the "o" command (not in
		insert mode!)
	"O"	if you use the "O" command (not in insert mode!)
	"e"	if you type the second 'e' for an "else" at the start of a
		line

Characters that can precede each key:				<b class="vimtag">*<a name="i_CTRL-F">i_CTRL-F</a>*</b>
!	When a '!' precedes the key, Vim will not insert the key but will
	instead reindent the current line.  This allows you to define a
	command key for reindenting the current line.  <code class="keystroke">CTRL-F</code> is the default
	key for this.  Be careful if you define <code class="keystroke">CTRL-I</code> for this because <code class="keystroke">CTRL-I</code>
	is the ASCII code for <code class="special">&lt;Tab&gt;</code>.
<b class="vimtag">*<a name="	When a '">	When a '</a>*</b>' precedes the key, Vim will reindent the line before
	inserting the key.  If 'cinkeys' contains "*<code class="special">&lt;Return&gt;</code>", Vim reindents
	the current line before opening a new line.
0	When a zero precedes the key (but appears after '!' or '*') Vim will
	reindent the line only if the key is the first character you type in
	the line.  When used before "=" Vim will only reindent the line if
	there is only white space before the word.

When neither '!' nor '*' precedes the key, Vim reindents the line after you
type the key.  So ';' sets the indentation of a line which includes the ';'.

Special key names:
<code class="special">&lt;&gt;</code>	Angle brackets mean spelled-out names of keys.  For example: "<code class="special">&lt;Up&gt;</code>",
	"<code class="special">&lt;Ins&gt;</code>" (see |<a href="intro.html#key-notation">key-notation</a>|).
^	Letters preceded by a caret (^) are control characters.  For example:
	"^F" is <code class="keystroke">CTRL-F</code>.
o	Reindent a line when you use the "o" command or when Vim opens a new
	line below the current one (e.g., when you type <code class="special">&lt;Enter&gt;</code> in insert
	mode).
O	Reindent a line when you use the "O" command.
e	Reindent a line that starts with "else" when you type the second 'e'.
:	Reindent a line when a ':' is typed which is after a label or case
	statement.  Don't reindent for a ":" in "class::method" for C++.  To
	Reindent for any ":", use "<code class="special">&lt;:&gt;</code>".
=word	Reindent when typing the last character of "word".  "word" may
	actually be part of another word.  Thus "=end" would cause reindenting
	when typing the "d" in "endif" or "endwhile".  But not when typing
	"bend".  Also reindent when completion produces a word that starts
	with "word".  "0=word" reindents when there is only white space before
	the word.
=~word	Like =word, but ignore case.

If you really want to reindent when you type 'o', 'O', 'e', '0', '<code class="special">&lt;', '&gt;</code>',
'<b class="vimtag">*<a name="', ':' or '!', use %22%3Co%3E%22, %22%3CO%3E%22, %22%3Ce%3E%22, %22%3C0%3E%22, %22%3C%3C%3E%22, %22%3C%3E%3E%22, %22%3C">', ':' or '!', use "&lt;o&gt;", "&lt;O&gt;", "&lt;e&gt;", "&lt;0&gt;", "&lt;&lt;&gt;", "&lt;&gt;&gt;", "&lt;</a>*</b>&gt;", "<code class="special">&lt;:&gt;</code>" or
"<code class="special">&lt;!&gt;</code>", respectively, for those keys.

For an emacs-style indent mode where lines aren't indented every time you
press <code class="special">&lt;Enter&gt;</code> but only if you press <code class="special">&lt;Tab&gt;</code>, I suggest:
	:set cinkeys=0<code class="special">{,0}</code>,:,0#,!<code class="special">&lt;Tab&gt;</code>,!^F
You might also want to switch off 'autoindent' then.

<code class="note">Note:</code> If you change the current line's indentation manually, Vim ignores the
cindent settings for that line.  This prevents vim from reindenting after you
have changed the indent by typing <code class="special">&lt;BS&gt;</code>, <code class="special">&lt;Tab&gt;</code>, or <code class="special">&lt;Space&gt;</code> in the indent or
used <code class="keystroke">CTRL-T</code> or <code class="keystroke">CTRL-D</code>.

						<b class="vimtag">*<a name="cinoptions-values">cinoptions-values</a>*</b>
The 'cinoptions' option sets how Vim performs indentation.  The value after
the option character can be one of these (N is any number):
	N	indent N spaces
	-N	indent N spaces to the left
	Ns	N times 'shiftwidth' spaces
	-Ns	N times 'shiftwidth' spaces to the left

In the list below,
"N" represents a number of your choice (the number can be negative).  When
there is an 's' after the number, Vim multiplies the number by 'shiftwidth':
"1s" is 'shiftwidth', "2s" is two times 'shiftwidth', etc.  You can use a
decimal point, too: "-0.5s" is minus half a 'shiftwidth'.
The examples below assume a 'shiftwidth' of 4.
							<b class="vimtag">*<a name="cino-%3E">cino-&gt;</a>*</b>
	&gt;N    Amount added for "normal" indent.  Used after a line that should
	      increase the indent (lines starting with "if", an opening brace,
	      etc.).  (default 'shiftwidth').

		cino=		    cino=&gt;2		cino=&gt;2s
<code class="example">		  if (cond)	      if (cond)		  if (cond)</code>
<code class="example">		  {		      {			  {</code>
<code class="example">		      foo;		foo;			  foo;</code>
<code class="example">		  }		      }			  }</code>

							<b class="vimtag">*<a name="cino-e">cino-e</a>*</b>
	eN    Add N to the prevailing indent inside a set of braces if the
	      opening brace at the End of the line (more precise: is not the
	      first character in a line).  This is useful if you want a
	      different indent when the '{' is at the start of the line from
	      when '{' is at the end of the line.  (default 0).

		cino=		    cino=e2		cino=e-2
<code class="example">		  if (cond) {	      if (cond) {	  if (cond) {</code>
<code class="example">		      foo;		    foo;	    foo;</code>
<code class="example">		  }		      }			  }</code>
<code class="example">		  else		      else		  else</code>
<code class="example">		  {		      {			  {</code>
<code class="example">		      bar;		  bar;		      bar;</code>
<code class="example">		  }		      }			  }</code>

							<b class="vimtag">*<a name="cino-n">cino-n</a>*</b>
	nN    Add N to the prevailing indent for a statement after an "if",
	      "while", etc., if it is NOT inside a set of braces.  This is
	      useful if you want a different indent when there is no '{'
	      before the statement from when there is a '{' before it.
	      (default 0).

		cino=		    cino=n2		cino=n-2
<code class="example">		  if (cond)	      if (cond)		  if (cond)</code>
<code class="example">		      foo;		    foo;	    foo;</code>
<code class="example">		  else		      else		  else</code>
<code class="example">		  {		      {			  {</code>
<code class="example">		      bar;		  bar;		      bar;</code>
<code class="example">		  }		      }			  }</code>

							<b class="vimtag">*<a name="cino-f">cino-f</a>*</b>
	fN    Place the first opening brace of a function or other block in
	      column N.  This applies only for an opening brace that is not
	      inside other braces and is at the start of the line.  What comes
	      after the brace is put relative to this brace.  (default 0).

		cino=		    cino=f.5s		cino=f1s
<code class="example">		  func()	      func()		  func()</code>
<code class="example">		  {			{		      {</code>
<code class="example">		      int foo;		    int foo;		  int foo;</code>

							<b class="vimtag">*<a name="cino-{">cino-{</a>*</b>
	{N    Place opening braces N characters from the prevailing indent.
	      This applies only for opening braces that are inside other
	      braces.  (default 0).

		cino=		    cino={.5s		cino={1s
<code class="example">		  if (cond)	      if (cond)		  if (cond)</code>
<code class="example">		  {			{		      {</code>
<code class="example">		      foo;		  foo;		      foo;</code>

							<b class="vimtag">*<a name="cino-}">cino-}</a>*</b>
	}N    Place closing braces N characters from the matching opening
	      brace.  (default 0).

		cino=		    cino=<code class="special">{2,}</code>-0.5s	cino=}2
<code class="example">		  if (cond)	      if (cond)		  if (cond)</code>
<code class="example">		  {			{		  {</code>
<code class="example">		      foo;		  foo;		      foo;</code>
<code class="example">		  }		      }			    }</code>

							<b class="vimtag">*<a name="cino-^">cino-^</a>*</b>
	^N    Add N to the prevailing indent inside a set of braces if the
	      opening brace is in column 0.  This can specify a different
	      indent for whole of a function (some may like to set it to a
	      negative number).  (default 0).

		cino=		    cino=^-2		cino=^-s
<code class="example">		  func()	      func()		  func()</code>
<code class="example">		  {		      {			  {</code>
<code class="example">		      if (cond)		if (cond)	  if (cond)</code>
<code class="example">		      {			{		  {</code>
<code class="example">			  a = b;	    a = b;	      a = b;</code>
<code class="example">		      }			}		  }</code>
<code class="example">		  }		      }			  }</code>

							<b class="vimtag">*<a name="cino-L">cino-L</a>*</b>
	LN    Controls placement of jump labels. If N is negative, the label
	      will be placed at column 1. If N is non-negative, the indent of
	      the label will be the prevailing indent minus N.  (default -1).

		cino=               cino=L2             cino=Ls
<code class="example">		  func()              func()              func()</code>
<code class="example">		  {                   {                   {</code>
<code class="example">		      {                   {                   {</code>
<code class="example">		          stmt;               stmt;               stmt;</code>
<code class="example">		  LABEL:                    LABEL:            LABEL:</code>
<code class="example">		      }                   }                   }</code>
<code class="example">		  }                   }                   }</code>

							<b class="vimtag">*<a name="cino-:">cino-:</a>*</b>
	:N    Place case labels N characters from the indent of the switch().
	      (default 'shiftwidth').

		cino=		    cino=:0
<code class="example">		  switch (x)	      switch(x)</code>
<code class="example">		  {		      {</code>
<code class="example">		      case 1:	      case 1:</code>
<code class="example">			  a = b;	  a = b;</code>
<code class="example">		      default:	      default:</code>
<code class="example">		  }		      }</code>

							<b class="vimtag">*<a name="cino-%20">cino-=</a>*</b>
	=N    Place statements occurring after a case label N characters from
	      the indent of the label.  (default 'shiftwidth').

		cino=		    cino==10
<code class="example">		   case 11:		case 11:  a = a + 1;</code>
<code class="example">		       a = a + 1;		  b = b + 1;</code>

							<b class="vimtag">*<a name="cino-l">cino-l</a>*</b>
	lN    If N != 0 Vim will align with a case label instead of the
	      statement after it in the same line.

		cino=			    cino=l1
<code class="example">		    switch (a) {	      switch (a) {</code>
<code class="example">			case 1: {		  case 1: {</code>
<code class="example">				    break;	      break;</code>
<code class="example">				}		  }</code>

							<b class="vimtag">*<a name="cino-b">cino-b</a>*</b>
	bN    If N != 0 Vim will align a final "break" with the case label,
	      so that case..break looks like a sort of block.  (default: 0).
	      When using 1, consider adding "0=break" to 'cinkeys'.

		cino=		    cino=b1
<code class="example">		  switch (x)	      switch(x)</code>
<code class="example">		  {		      {</code>
<code class="example">		      case 1:		  case 1:</code>
<code class="example">			  a = b;	      a = b;</code>
<code class="example">			  break;	  break;</code>
<code class="example"></code>
<code class="example">		      default:		  default:</code>
<code class="example">			  a = 0;	      a = 0;</code>
<code class="example">			  break;	  break;</code>
<code class="example">		  }		      }</code>

							<b class="vimtag">*<a name="cino-g">cino-g</a>*</b>
	gN    Place C++ scope declarations N characters from the indent of the
	      block they are in.  (default 'shiftwidth').  A scope declaration
	      can be "public:", "protected:" or "private:".

		cino=		    cino=g0
<code class="example">		  {		      {</code>
<code class="example">		      public:	      public:</code>
<code class="example">			  a = b;	  a = b;</code>
<code class="example">		      private:	      private:</code>
<code class="example">		  }		      }</code>

							<b class="vimtag">*<a name="cino-h">cino-h</a>*</b>
	hN    Place statements occurring after a C++ scope declaration N
	      characters from the indent of the label.  (default
	      'shiftwidth').

		cino=		    cino=h10
<code class="example">		   public:		public:   a = a + 1;</code>
<code class="example">		       a = a + 1;		  b = b + 1;</code>

							<b class="vimtag">*<a name="cino-N">cino-N</a>*</b>
	NN    Indent inside C++ namespace N characters extra compared to a
	      normal block.  (default 0).

		cino=			   cino=N-s
<code class="example">		  namespace {                namespace {</code>
<code class="example">		      void function();       void function();</code>
<code class="example">		  }                          }</code>
<code class="example"></code>
<code class="example">		  namespace my               namespace my</code>
<code class="example">		  {                          {</code>
<code class="example">		      void function();       void function();</code>
<code class="example">		  }                          }</code>

							<b class="vimtag">*<a name="cino-E">cino-E</a>*</b>
	EN    Indent inside C++ linkage specifications (extern "C" or
	      extern "C++") N characters extra compared to a normal block.
	      (default 0).

		cino=			   cino=E-s
<code class="example">		  extern "C" {               extern "C" {</code>
<code class="example">		      void function();       void function();</code>
<code class="example">		  }                          }</code>
<code class="example"></code>
<code class="example">		  extern "C"                 extern "C"</code>
<code class="example">		  {                          {</code>
<code class="example">		      void function();       void function();</code>
<code class="example">		  }                          }</code>

							<b class="vimtag">*<a name="cino-p">cino-p</a>*</b>
	pN    Parameter declarations for K&amp;R-style function declarations will
	      be indented N characters from the margin.  (default
	      'shiftwidth').

		cino=		    cino=p0		cino=p2s
<code class="example">		  func(a, b)	      func(a, b)	  func(a, b)</code>
<code class="example">		      int a;	      int a;			  int a;</code>
<code class="example">		      char b;	      char b;			  char b;</code>

							<b class="vimtag">*<a name="cino-t">cino-t</a>*</b>
	tN    Indent a function return type declaration N characters from the
	      margin.  (default 'shiftwidth').

		cino=		    cino=t0		cino=t7
<code class="example">		      int	      int			 int</code>
<code class="example">		  func()	      func()		  func()</code>

							<b class="vimtag">*<a name="cino-i">cino-i</a>*</b>
	iN    Indent C++ base class declarations and constructor
	      initializations, if they start in a new line (otherwise they
	      are aligned at the right side of the ':').
	      (default 'shiftwidth').

		cino=			  cino=i0
<code class="example">		  class MyClass :	    class MyClass :</code>
<code class="example">		      public BaseClass      public BaseClass</code>
<code class="example">		  <code class="special">{}</code>			    <code class="special">{}</code></code>
<code class="example">		  MyClass::MyClass() :	    MyClass::MyClass() :</code>
<code class="example">		      BaseClass(3)	    BaseClass(3)</code>
<code class="example">		  <code class="special">{}</code>			    <code class="special">{}</code></code>

							<b class="vimtag">*<a name="cino-+">cino-+</a>*</b>
	+N    Indent a continuation line (a line that spills onto the next)
              inside a function N additional characters.  (default
              'shiftwidth').
              Outside of a function, when the previous line ended in a
              backslash, the 2 * N is used.

		cino=			  cino=+10
<code class="example">		  a = b + 9 <b class="vimtag">*<a name="		    a %20 b + 9 ">		    a = b + 9 </a>*</b></code>
<code class="example">		      c;			      c;</code>

							<b class="vimtag">*<a name="cino-c">cino-c</a>*</b>
	cN    Indent comment lines after the comment opener, when there is no
	      other text with which to align, N characters from the comment
	      opener.  (default 3).  See also |<a href="change.html#format-comments">format-comments</a>|.

		cino=			  cino=c5
<code class="example">		  /<b class="vimtag">*<a name="			    %2F">			    /</a>*</b></code>
<code class="example">		     text.			 text.</code>
<code class="example">		   <b class="vimtag">*<a name="%2F			     ">/			     </a>*</b>/</code>

							<b class="vimtag">*<a name="cino-C">cino-C</a>*</b>
	CN    When N is non-zero, indent comment lines by the amount specified
	      with the c flag above even if there is other text behind the
	      comment opener.  (default 0).

		cino=c0			  cino=c0,C1
<code class="example">		  /*******<b class="vimtag">*<a name="		    %2F">		    /</a>*</b>*******</code>
<code class="example">		    text.		    text.</code>
<code class="example">		  *******<b class="vimtag">*<a name="%2F		    ">/		    </a>*</b>*******/</code>
	      (Example uses ":set comments&amp; comments-=s1:/<b class="vimtag">*<a name=" comments^%20s0:%2F"> comments^=s0:/</a>*</b>")

							<b class="vimtag">*<a name="cino-%2F">cino-/</a>*</b>
	/N    Indent comment lines N characters extra.  (default 0).
		cino=			  cino=/4
<code class="example">		  a = b;		    a = b;</code>
<code class="example">		  /<b class="vimtag">*<a name=" comment "> comment </a>*</b>/			/<b class="vimtag">*<a name=" comment "> comment </a>*</b>/</code>
<code class="example">		  c = d;		    c = d;</code>

							<b class="vimtag">*<a name="cino-(">cino-(</a>*</b>
	(N    When in unclosed parentheses, indent N characters from the line
	      with the unclosed parentheses.  Add a 'shiftwidth' for every
	      extra unclosed parentheses.  When N is 0 or the unclosed
	      parentheses is the first non-white character in its line, line
	      up with the next non-white character after the unclosed
	      parentheses.  (default 'shiftwidth' * 2).

		cino=			  cino=(0
<code class="example">		  if (c1 &amp;&amp; (c2 ||<code class="badlink">	    if (c1 && (c2 </code>||</code>
<code class="example">			      c3))		       c3))</code>
<code class="example">		      foo;			foo;</code>
<code class="example">		  if (c1 &amp;&amp;		    if (c1 &amp;&amp;</code>
<code class="example">			  (c2 ||<code class="badlink"> c3))		(c2 </code>|| c3))</code>
<code class="example">		     {			       {</code>

							<b class="vimtag">*<a name="cino-u">cino-u</a>*</b>
	uN    Same as (N, but for one nesting level deeper.
	      (default 'shiftwidth').

		cino=			  cino=u2
<code class="example">		  if (c123456789	    if (c123456789</code>
<code class="example">			  &amp;&amp; (c22345		    &amp;&amp; (c22345</code>
<code class="example">			      ||<code class="badlink"> c3))		      </code>|| c3))</code>

							<b class="vimtag">*<a name="cino-U">cino-U</a>*</b>
	UN    When N is non-zero, do not ignore the indenting specified by
	      ( or u in case that the unclosed parentheses is the first
	      non-white character in its line.  (default 0).

		cino= or cino=(s	  cino=(s,U1
<code class="example">		  c = c1 &amp;&amp;		    c = c1 &amp;&amp;</code>
<code class="example">		      (				(</code>
<code class="example">		       c2 ||<code class="badlink">			    c2 </code>||</code>
<code class="example">		       c3			    c3</code>
<code class="example">		      ) &amp;&amp; c4;			) &amp;&amp; c4;</code>

							<b class="vimtag">*<a name="cino-w">cino-w</a>*</b>
	wN    When in unclosed parentheses and N is non-zero and either
	      using "(0" or "u0", respectively, or using "U0" and the unclosed
	      parentheses is the first non-white character in its line, line
	      up with the character immediately after the unclosed parentheses
	      rather than the first non-white character.  (default 0).

		cino=(0			  cino=(0,w1
<code class="example">		  if (   c1		    if (   c1</code>
<code class="example">			 &amp;&amp; (   c2		&amp;&amp; (   c2</code>
<code class="example">				||<code class="badlink"> c3))		    </code>|| c3))</code>
<code class="example">		      foo;			foo;</code>

							<b class="vimtag">*<a name="cino-W">cino-W</a>*</b>
	WN    When in unclosed parentheses and N is non-zero and either
	      using "(0" or "u0", respectively and the unclosed parentheses is
	      the last non-white character in its line and it is not the
	      closing parentheses, indent the following line N characters
	      relative to the outer context (i.e. start of the line or the
	      next unclosed parentheses).  (default: 0).

		cino=(0			   cino=(0,W4
<code class="example">		  a_long_line(		    a_long_line(</code>
<code class="example">			      argument,		argument,</code>
<code class="example">			      argument);	argument);</code>
<code class="example">		  a_short_line(argument,    a_short_line(argument,</code>
<code class="example">			       argument);		 argument);</code>

							<b class="vimtag">*<a name="cino-k">cino-k</a>*</b>
	kN    When in unclosed parentheses which follow "if", "for" or
	      "while" and N is non-zero, overrides the behaviour defined by
	      "(N": causes the indent to be N characters relative to the outer
	      context (i.e. the line where "if", "for" or "while" is).  Has
	      no effect on deeper levels of nesting.  Affects flags like "wN"
	      only for the "if", "for" and "while" conditions.  If 0, defaults
	      to behaviour defined by the "(N" flag.  (default: 0).

		cino=(0			   cino=(0,ks
<code class="example">		  if (condition1	    if (condition1</code>
<code class="example">		      &amp;&amp; condition2)		    &amp;&amp; condition2)</code>
<code class="example">		      action();			action();</code>
<code class="example">		  function(argument1	    function(argument1</code>
<code class="example">			   &amp;&amp; argument2);	     &amp;&amp; argument2);</code>

							<b class="vimtag">*<a name="cino-m">cino-m</a>*</b>
	mN    When N is non-zero, line up a line starting with a closing
	      parentheses with the first character of the line with the
	      matching opening parentheses.  (default 0).

		cino=(s			  cino=(s,m1
<code class="example">		  c = c1 &amp;&amp; (		    c = c1 &amp;&amp; (</code>
<code class="example">		      c2 ||<code class="badlink">			c2 </code>||</code>
<code class="example">		      c3			c3</code>
<code class="example">		      ) &amp;&amp; c4;		    ) &amp;&amp; c4;</code>
<code class="example">		  if (			    if (</code>
<code class="example">		      c1 &amp;&amp; c2			c1 &amp;&amp; c2</code>
<code class="example">		     )			    )</code>
<code class="example">		      foo;			foo;</code>

							<b class="vimtag">*<a name="cino-M">cino-M</a>*</b>
	MN    When N is non-zero, line up a line starting with a closing
	      parentheses with the first character of the previous line.
	      (default 0).

		cino=			  cino=M1
<code class="example">		  if (cond1 &amp;&amp;		    if (cond1 &amp;&amp;</code>
<code class="example">			 cond2			   cond2</code>
<code class="example">		     )				   )</code>

				<b class="vimtag">*<a name="java-cinoptions">java-cinoptions</a>*</b> <b class="vimtag">*<a name="java-indenting">java-indenting</a>*</b> <b class="vimtag">*<a name="cino-j">cino-j</a>*</b>
	jN    Indent Java anonymous classes correctly.  Also works well for
	      Javascript.  The value 'N' is currently unused but must be
	      non-zero (e.g. 'j1').  'j1' will indent for example the
	      following code snippet correctly:
<code class="example"></code>
<code class="example">		object.add(new ChangeListener() {</code>
<code class="example">		    public void stateChanged(ChangeEvent e) {</code>
<code class="example">			do_something();</code>
<code class="example">		    }</code>
<code class="example">		});</code>

			<b class="vimtag">*<a name="javascript-cinoptions">javascript-cinoptions</a>*</b> <b class="vimtag">*<a name="javascript-indenting">javascript-indenting</a>*</b> <b class="vimtag">*<a name="cino-J">cino-J</a>*</b>
	JN    Indent JavaScript object declarations correctly by not confusing
	      them with labels.  The value 'N' is currently unused but must be
	      non-zero (e.g. 'J1').  If you enable this you probably also want
	      to set |<a href="indent.html#cino-j">cino-j</a>|.
<code class="example"></code>
<code class="example">		var bar = {</code>
<code class="example">		    foo: {</code>
<code class="example">			that: this,</code>
<code class="example">			some: ok,</code>
<code class="example">		    },</code>
<code class="example">		    "bar":{</code>
<code class="example">			a : 2,</code>
<code class="example">			b: "123abc",</code>
<code class="example">			x: 4,</code>
<code class="example">			"y": 5</code>
<code class="example">		    }</code>
<code class="example">		}</code>

								<b class="vimtag">*<a name="cino-)">cino-)</a>*</b>
	)N    Vim searches for unclosed parentheses at most N lines away.
	      This limits the time needed to search for parentheses.  (default
	      20 lines).

								<b class="vimtag">*<a name="cino-star">cino-star</a>*</b>
	*N    Vim searches for unclosed comments at most N lines away.  This
	      limits the time needed to search for the start of a comment.
	      If your /<b class="vimtag">*<a name=" "> </a>*</b>/ comments stop indenting after N lines this is the
	      value you will want to change.
	      (default 70 lines).

								<b class="vimtag">*<a name="cino-%23">cino-#</a>*</b>
	#N    When N is non-zero recognize shell/Perl comments starting with
	      '#', do not recognize preprocessor lines; allow right-shifting
	      lines that start with "#".
	      When N is zero (default): don't recognize '#' comments, do
	      recognize preprocessor lines; right-shifting lines that start
	      with "#" does not work.


The defaults, spelled out in full, are:
	cinoptions=&gt;s,e0,n0,f0,<code class="special">{0,}</code>0,^0,L-1,:s,=s,l0,b0,gs,hs,N0,E0,ps,ts,is,+s,
			c3,C0,/0,(2s,us,U0,w0,W0,k0,m0,j0,J0,)20,*70,#0

Vim puts a line in column 1 if:
- It starts with '#' (preprocessor directives), if 'cinkeys' contains '#0'.
- It starts with a label (a keyword followed by ':', other than "case" and
  "default") and 'cinoptions' does not contain an 'L' entry with a positive
  value.
- Any combination of indentations causes the line to have less than 0
  indentation.

</pre><hr/><pre>2. Indenting by expression				<b class="vimtag">*<a name="indent-expression">indent-expression</a>*</b>

The basics for using flexible indenting are explained in section |<a href="usr_30.html#30.3">30.3</a>| of the
user manual.

If you want to write your own indent file, it must set the 'indentexpr'
option.  Setting the 'indentkeys' option is often useful.
See the $VIMRUNTIME/indent/README.txt file for hints.
See the $VIMRUNTIME/indent directory for examples.


<code class="section">REMARKS ABOUT SPECIFIC INDENT FILES </code>


CLOJURE					<b class="vimtag">*<a name="ft-clojure-indent">ft-clojure-indent</a>*</b> <b class="vimtag">*<a name="clojure-indent">clojure-indent</a>*</b>

Clojure indentation differs somewhat from traditional Lisps, due in part to
the use of square and curly brackets, and otherwise by community convention.
These conventions are not universally followed, so the Clojure indent script
offers a few configurable options, listed below.

If the current vim does not include |<a href="eval.html#searchpairpos()">searchpairpos()</a>|, the indent script falls
back to normal 'lisp' indenting, and the following options are ignored.

							<b class="vimtag">*<a name="g:clojure_maxlines">g:clojure_maxlines</a>*</b>

Set maximum scan distance of |<a href="eval.html#searchpairpos()">searchpairpos()</a>|. Larger values trade
performance for correctness when dealing with very long forms. A value of 0
will scan without limits.

<code class="example">	" Default</code>
<code class="example">	let g:clojure_maxlines = 100</code>

						<b class="vimtag">*<a name="g:clojure_fuzzy_indent">g:clojure_fuzzy_indent</a>*</b>
					<b class="vimtag">*<a name="g:clojure_fuzzy_indent_patterns">g:clojure_fuzzy_indent_patterns</a>*</b>
					<b class="vimtag">*<a name="g:clojure_fuzzy_indent_blacklist">g:clojure_fuzzy_indent_blacklist</a>*</b>

The 'lispwords' option is a list of comma-separated words that mark special
forms whose subforms must be indented with two spaces.

For example:

<code class="example">	(defn bad []</code>
<code class="example">	      "Incorrect indentation")</code>
<code class="example"></code>
<code class="example">	(defn good []</code>
<code class="example">	  "Correct indentation")</code>

If you would like to specify 'lispwords' with a |<a href="pattern.html#pattern">pattern</a>| instead, you can use
the fuzzy indent feature:

<code class="example">	" Default</code>
<code class="example">	let g:clojure_fuzzy_indent = 1</code>
<code class="example">	let g:clojure_fuzzy_indent_patterns = ['^with', '^def', '^let']</code>
<code class="example">	let g:clojure_fuzzy_indent_blacklist =</code>
<code class="example">		\ ['-fn$', '\v^with-%(meta|<code class="badlink">out-str</code>|loading-context)$']</code>
<code class="example"></code>
<code class="example">	" Legacy comma-delimited string version; the list format above is</code>
<code class="example">	" recommended. <code class="note">Note</code> that patterns are implicitly anchored with ^ and $</code>
<code class="example">	let g:clojure_fuzzy_indent_patterns = 'with.<b class="vimtag">*<a name=",def.">,def.</a>*</b>,let.*'</code>

|<a href="indent.html#g:clojure_fuzzy_indent_patterns">g:clojure_fuzzy_indent_patterns</a>| and |<a href="indent.html#g:clojure_fuzzy_indent_blacklist">g:clojure_fuzzy_indent_blacklist</a>| are
|<a href="eval.html#Lists">Lists</a>| of patterns that will be matched against the unquoted, unqualified
symbol at the head of a list. This means that a pattern like "^foo" will match
all these candidates: "foobar", "my.ns/foobar", and "#'foobar".

Each candidate word is tested for special treatment in this order:

	1. Return true if word is literally in 'lispwords'
	2. Return false if word matches a pattern in
	   |<a href="indent.html#g:clojure_fuzzy_indent_blacklist">g:clojure_fuzzy_indent_blacklist</a>|
	3. Return true if word matches a pattern in
	   |<a href="indent.html#g:clojure_fuzzy_indent_patterns">g:clojure_fuzzy_indent_patterns</a>|
	4. Return false and indent normally otherwise

					<b class="vimtag">*<a name="g:clojure_special_indent_words">g:clojure_special_indent_words</a>*</b>

Some forms in Clojure are indented so that every subform is indented only two
spaces, regardless of 'lispwords'. If you have a custom construct that should
be indented in this idiosyncratic fashion, you can add your symbols to the
default list below.

<code class="example">	" Default</code>
<code class="example">	let g:clojure_special_indent_words =</code>
<code class="example">	   \ 'deftype,defrecord,reify,proxy,extend-type,extend-protocol,letfn'</code>

					<b class="vimtag">*<a name="g:clojure_align_multiline_strings">g:clojure_align_multiline_strings</a>*</b>

Align subsequent lines in multiline strings to the column after the opening
quote, instead of the same column.

For example:

<code class="example">	(def default</code>
<code class="example">	  "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do</code>
<code class="example">	  eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut</code>
<code class="example">	  enim ad minim veniam, quis nostrud exercitation ullamco laboris</code>
<code class="example">	  nisi ut aliquip ex ea commodo consequat.")</code>
<code class="example"></code>
<code class="example">	(def aligned</code>
<code class="example">	  "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do</code>
<code class="example">	   eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut</code>
<code class="example">	   enim ad minim veniam, quis nostrud exercitation ullamco laboris</code>
<code class="example">	   nisi ut aliquip ex ea commodo consequat.")</code>

This option is off by default.

<code class="example">	" Default</code>
<code class="example">	let g:clojure_align_multiline_strings = 0</code>

						<b class="vimtag">*<a name="g:clojure_align_subforms">g:clojure_align_subforms</a>*</b>

By default, parenthesized compound forms that look like function calls and
whose head subform is on its own line have subsequent subforms indented by
two spaces relative to the opening paren:

<code class="example">	(foo</code>
<code class="example">	  bar</code>
<code class="example">	  baz)</code>

Setting this option changes this behavior so that all subforms are aligned to
the same column, emulating the default behavior of clojure-mode.el:

<code class="example">	(foo</code>
<code class="example">	 bar</code>
<code class="example">	 baz)</code>

This option is off by default.

<code class="example">	" Default</code>
<code class="example">	let g:clojure_align_subforms = 0</code>


FORTRAN							<b class="vimtag">*<a name="ft-fortran-indent">ft-fortran-indent</a>*</b>

Block if, select case, where, and forall constructs are indented.  So are
type, interface, associate, block, and enum constructs.  The indenting of
subroutines, functions, modules, and program blocks is optional.  Comments,
labelled statements and continuation lines are indented if the Fortran is in
free source form, whereas they are not indented if the Fortran is in fixed
source form because of the left margin requirements.  Hence manual indent
corrections will be necessary for labelled statements and continuation lines
when fixed source form is being used.  For further discussion of the method
used for the detection of source format see |<a href="syntax.html#ft-fortran-syntax">ft-fortran-syntax</a>|.

<code class="section">Do loops </code>
All do loops are left unindented by default.  Do loops can be unstructured in
Fortran with (possibly multiple) loops ending on a labelled executable
statement of almost arbitrary type.  Correct indentation requires
compiler-quality parsing.  Old code with do loops ending on labelled statements
of arbitrary type can be indented with elaborate programs such as Tidy
(http://www.unb.ca/chem/ajit/f_tidy.htm).  Structured do/continue loops are
also left unindented because continue statements are also used for purposes
other than ending a do loop.  Programs such as Tidy can convert structured
do/continue loops to the do/enddo form.  Do loops of the do/enddo variety can
be indented.  If you use only structured loops of the do/enddo form, you should
declare this by setting the fortran_do_enddo variable in your .vimrc as
follows
<code class="example"></code>
<code class="example">   let fortran_do_enddo=1</code>
<code class="example"></code>
in which case do loops will be indented.  If all your loops are of do/enddo
type only in, say, .f90 files, then you should set a buffer flag with an
autocommand such as
<code class="example"></code>
<code class="example">  au! BufRead,BufNewFile *.f90 let b:fortran_do_enddo=1</code>
<code class="example"></code>
to get do loops indented in .f90 files and left alone in Fortran files with
other extensions such as .for.

<code class="section">Program units </code>
The indenting of program units (subroutines, functions, modules, and program
blocks) is enabled by default but can be suppressed if a lighter, screen-width
preserving indent style is desired.  To suppress the indenting of program
units for all fortran files set the global fortran_indent_less variable in
your .vimrc as follows
<code class="example"></code>
<code class="example">  let fortran_indent_less=1</code>
<code class="example"></code>
A finer level of suppression can be achieved by setting the corresponding
buffer-local variable as follows
<code class="example"></code>
<code class="example">  let b:fortran_indent_less=1</code>
<code class="example"></code>
<code class="example"></code>
HTML				<b class="vimtag">*<a name="ft-html-indent">ft-html-indent</a>*</b> <b class="vimtag">*<a name="html-indent">html-indent</a>*</b> <b class="vimtag">*<a name="html-indenting">html-indenting</a>*</b>

This is about variables you can set in your vimrc to customize HTML indenting.

You can set the indent for the first line after <code class="special">&lt;script&gt;</code> and <code class="special">&lt;style&gt;</code>
"blocktags" (default "zero"):
<code class="example"></code>
<code class="example">      :let g:html_indent_script1 = "inc"</code>
<code class="example">      :let g:html_indent_style1 = "inc"</code>

<code class="section">      VALUE	MEANING </code>
      "zero"	zero indent
      "auto"	auto indent (same indent as the blocktag)
      "inc"	auto indent + one indent step

Many tags increase the indent for what follows per default (see "Add Indent
Tags" in the script).  You can add further tags with:
<code class="example"></code>
<code class="example">      :let g:html_indent_inctags = "html,body,head,tbody"</code>
<code class="example"></code>
You can also remove such tags with:
<code class="example"></code>
<code class="example">      :let g:html_indent_autotags = "th,td,tr,tfoot,thead"</code>
<code class="example"></code>
Default value is empty for both variables.  <code class="note">Note:</code> the initial "inctags" are
only defined once per Vim session.

User variables are only read when the script is sourced.  To enable your
changes during a session, without reloading the HTML file, you can manually
do:
<code class="example"></code>
<code class="example">      :call HtmlIndent_CheckUserSettings()</code>
<code class="example"></code>
Detail:
  Calculation of indent inside "blocktags" with "alien" content:
<code class="section">      BLOCKTAG   INDENT EXPR	    WHEN APPLICABLE </code>
      <code class="special">&lt;script&gt;</code> : <code class="special">{customizable}</code>	    if first line of block
	       : cindent(v:lnum)    if attributes empty or contain "java"
	       : -1		    else (vbscript, tcl, ...)
      <code class="special">&lt;style&gt;</code>  : <code class="special">{customizable}</code>	    if first line of block
	       : GetCSSIndent()	    else
      <code class="special">&lt;!-- --&gt;</code> : -1


MATLAB			<b class="vimtag">*<a name="ft-matlab-indent">ft-matlab-indent</a>*</b> <b class="vimtag">*<a name="matlab-indent">matlab-indent</a>*</b> <b class="vimtag">*<a name="matlab-indenting">matlab-indenting</a>*</b>

The setting Function indenting format in MATLAB Editor/Debugger Language
Preferences corresponds to:
<code class="example">    :let g:MATLAB_function_indent = <code class="special">{0, 1 or 2 (default)}</code></code>
<code class="example"></code>
Where 0 is for Classic, 1 for Indent nested functions and 2 for Indent all
functions.


PHP				<b class="vimtag">*<a name="ft-php-indent">ft-php-indent</a>*</b> <b class="vimtag">*<a name="php-indent">php-indent</a>*</b> <b class="vimtag">*<a name="php-indenting">php-indenting</a>*</b>

<code class="note">NOTE:</code>	PHP files will be indented correctly only if PHP |<a href="syntax.html#syntax">syntax</a>| is active.

If you are editing a file in Unix 'fileformat' and '\r' characters are present
before new lines, indentation won't proceed correctly ; you have to remove
those useless characters first with a command like:
<code class="example"></code>
<code class="example">    :%s /\r$//g</code>
<code class="example"></code>
Or, you can simply |<a href="eval.html#:let">:let</a>| the variable PHP_removeCRwhenUnix to 1 and the
script will silently remove them when Vim loads a PHP file (at each |<a href="autocmd.html#BufRead">BufRead</a>|).

<code class="section">OPTIONS: </code>

PHP indenting can be altered in several ways by modifying the values of some
global variables:

					<b class="vimtag">*<a name="php-comment">php-comment</a>*</b> <b class="vimtag">*<a name="PHP_autoformatcomment">PHP_autoformatcomment</a>*</b>
To not enable auto-formatting of comments by default (if you want to use your
own 'formatoptions'):
<code class="example">    :let g:PHP_autoformatcomment = 0</code>
<code class="example"></code>
Else, 't' will be removed from the 'formatoptions' string and "qrowcb" will be
added, see |<a href="change.html#fo-table">fo-table</a>| for more information.
</pre><hr/><pre>
							<b class="vimtag">*<a name="PHP_outdentSLComments">PHP_outdentSLComments</a>*</b>
To add extra indentation to single-line comments:
<code class="example">    :let g:PHP_outdentSLComments = N</code>
<code class="example"></code>
With N being the number of 'shiftwidth' to add.

Only single-line comments will be affected such as:
<code class="example">    # Comment</code>
<code class="example">    // Comment</code>
<code class="example">    /<b class="vimtag">*<a name=" Comment "> Comment </a>*</b>/</code>
</pre><hr/><pre><code class="example"></code>
<code class="example">							<b class="vimtag">*<a name="PHP_default_indenting">PHP_default_indenting</a>*</b></code>
To add extra indentation to every PHP lines with N being the number of
'shiftwidth' to add:
<code class="example">    :let g:PHP_default_indenting = N</code>
<code class="example"></code>
For example, with N = 1, this will give:

<code class="example">    &lt;?php</code>
<code class="example">	if (!isset($History_lst_sel))</code>
<code class="example">	    if (!isset($History_lst_sel))</code>
<code class="example">		if (!isset($History_lst_sel)) {</code>
<code class="example">		    $History_lst_sel=0;</code>
<code class="example">		} else</code>
<code class="example">		    $foo="bar";</code>
<code class="example"></code>
<code class="example">	$command_hist = TRUE;</code>
<code class="example">    ?&gt;</code>
(Notice the extra indentation between the PHP container markers and the code)
</pre><hr/><pre>
							<b class="vimtag">*<a name="PHP_outdentphpescape">PHP_outdentphpescape</a>*</b>
To indent PHP escape tags as the surrounding non-PHP code (only affects the
PHP escape tags):
:let g:PHP_outdentphpescape = 0
</pre><hr/><pre>
							<b class="vimtag">*<a name="PHP_removeCRwhenUnix">PHP_removeCRwhenUnix</a>*</b>
To automatically remove '\r' characters when the 'fileformat' is set to Unix:
<code class="example">    :let g:PHP_removeCRwhenUnix = 1</code>
</pre><hr/><pre><code class="example"></code>
<code class="example">							<b class="vimtag">*<a name="PHP_BracesAtCodeLevel">PHP_BracesAtCodeLevel</a>*</b></code>
To indent braces at the same level than the code they contain:
<code class="example">    :let g:PHP_BracesAtCodeLevel = 1</code>
<code class="example"></code>
This will give the following result:
<code class="example">    if ($foo)</code>
<code class="example">	{</code>
<code class="example">	foo();</code>
<code class="example">	}</code>
Instead of:
<code class="example">    if ($foo)</code>
<code class="example">    {</code>
<code class="example">	foo();</code>
<code class="example">    }</code>
<code class="example"></code>
<code class="note">NOTE:</code>	Indenting will be a bit slower if this option is used because some
	optimizations won't be available.
</pre><hr/><pre>
					<b class="vimtag">*<a name="PHP_vintage_case_default_indent">PHP_vintage_case_default_indent</a>*</b>
To indent 'case:' and 'default:' statements in switch() blocks:
<code class="example">    :let g:PHP_vintage_case_default_indent = 1</code>
<code class="example"></code>
In PHP braces are not required inside 'case/default' blocks therefore 'case:'
and 'default:' are indented at the same level than the 'switch()' to avoid
meaningless indentation. You can use the above option to return to the
traditional way.
</pre><hr/><pre>
							<b class="vimtag">*<a name="PHP_noArrowMatching">PHP_noArrowMatching</a>*</b>
By default the indent script will indent multi-line chained calls by matching
the position of the '-&gt;':
<code class="example"></code>
<code class="example">    $user_name_very_long-&gt;name()</code>
<code class="example">                        -&gt;age()</code>
<code class="example">                        -&gt;info();</code>
<code class="example"></code>
You can revert to the classic way of indenting by setting this option to 1:
<code class="example">    :let g:PHP_noArrowMatching = 1</code>
<code class="example"></code>
You will obtain the following result:
<code class="example"></code>
<code class="example">    $user_name_very_long-&gt;name()</code>
<code class="example">        -&gt;age()</code>
<code class="example">        -&gt;info();</code>
<code class="example"></code>
</pre><hr/><pre><code class="example"></code>
<code class="example">					<b class="vimtag">*<a name="PHP_IndentFunctionCallParameters">PHP_IndentFunctionCallParameters</a>*</b></code>
Extra indentation levels to add to parameters in multi-line function calls.
<code class="example">    let g:PHP_IndentFunctionCallParameters = 1</code>
<code class="example"></code>
Function call arguments will indent 1 extra level. For two-space indentation:
<code class="example"></code>
<code class="example">    function call_the_thing(</code>
<code class="example">      $with_this,</code>
<code class="example">      $and_that</code>
<code class="example">    ) {</code>
<code class="example">      $this-&gt;do_the_thing(</code>
<code class="example">          $with_this,</code>
<code class="example">          $and_that</code>
<code class="example">      );</code>
<code class="example">    }</code>
<code class="example"></code>
</pre><hr/><pre><code class="example"></code>
<code class="example">				<b class="vimtag">*<a name="PHP_IndentFunctionDeclarationParameters">PHP_IndentFunctionDeclarationParameters</a>*</b></code>
Extra indentation levels to add to arguments in multi-line function
definitions.
<code class="example">    let g:PHP_IndentFunctionDeclarationParameters = 1</code>
<code class="example"></code>
Function arguments in declarations will indent 1 extra level. For two-space
indentation:
<code class="example"></code>
<code class="example">    function call_the_thing(</code>
<code class="example">        $with_this,</code>
<code class="example">        $and_that</code>
<code class="example">    ) {</code>
<code class="example">      $this-&gt;do_the_thing(</code>
<code class="example">        $with_this,</code>
<code class="example">        $and_that</code>
<code class="example">      );</code>
<code class="example">    }</code>
<code class="example"></code>
<code class="example"></code>
PYTHON							<b class="vimtag">*<a name="ft-python-indent">ft-python-indent</a>*</b>

The amount of indent can be set for the following situations.  The examples
given are the defaults.  <code class="note">Note</code> that the variables are set to an expression, so
that you can change the value of 'shiftwidth' later.

Indent after an open paren:
<code class="example">	let g:pyindent_open_paren = 'shiftwidth() * 2'</code>
Indent after a nested paren:
<code class="example">	let g:pyindent_nested_paren = 'shiftwidth()'</code>
Indent for a continuation line:
<code class="example">	let g:pyindent_continue = 'shiftwidth() * 2'</code>
<code class="example"></code>
The method uses |<a href="eval.html#searchpair()">searchpair()</a>| to look back for unclosed parenthesis.  This
can sometimes be slow, thus it timeouts after 150 msec.  If you notice the
indenting isn't correct, you can set a larger timeout in msec:
<code class="example">	let g:pyindent_searchpair_timeout = 500</code>
<code class="example"></code>
If looking back for unclosed parenthesis is still too slow, especially during
a copy-paste operation, or if you don't need indenting inside multi-line
parentheses, you can completely disable this feature:
<code class="example">	let g:pyindent_disable_parentheses_indenting = 1</code>
<code class="example"></code>
<code class="example"></code>
R								<b class="vimtag">*<a name="ft-r-indent">ft-r-indent</a>*</b>

Function arguments are aligned if they span for multiple lines. If you prefer
do not have the arguments of functions aligned, put in your |<a href="starting.html#vimrc">vimrc</a>|:

<code class="example">   let r_indent_align_args = 0</code>

All lines beginning with a comment character, #, get the same indentation
level of the normal R code. Users of Emacs/ESS may be used to have lines
beginning with a single # indented in the 40th column, ## indented as R code,
and ### not indented. If you prefer that lines beginning with comment
characters are aligned as they are by Emacs/ESS, put in your |<a href="starting.html#vimrc">vimrc</a>|:

<code class="example">   let r_indent_ess_comments = 1</code>

If you prefer that lines beginning with a single # are aligned at a column
different from the 40th one, you should set a new value to the variable
r_indent_comment_column, as in the example below:

<code class="example">   let r_indent_comment_column = 30</code>

Any code after a line that ends with "&lt;-" is indented. Emacs/ESS does not
indent the code if it is a top level function. If you prefer that the
Vim-R-plugin behaves like Emacs/ESS in this regard, put in your |<a href="starting.html#vimrc">vimrc</a>|:

<code class="example">   let r_indent_ess_compatible = 1</code>

Below is an example of indentation with and without this option enabled:

<code class="example">   ### r_indent_ess_compatible = 1           ### r_indent_ess_compatible = 0</code>
<code class="example">   foo &lt;-                                    foo &lt;-</code>
<code class="example">       function(x)                               function(x)</code>
<code class="example">   {                                             {</code>
<code class="example">       paste(x)                                      paste(x)</code>
<code class="example">   }                                             }</code>

The code will be indented after lines that match the pattern
`'\(&amp;\||<code class="badlink">\</code>|+\|<code class="badlink">-\</code>|\<b class="vimtag">*<a name="\|%2F\|%20\|\%7E\|%\|-%3E\)\s">\|/\|=\|\~\|%\|-&gt;\)\s</a>*</b>$'`. If you want indentation after
lines that match a different pattern, you should set the appropriate value of
`r_indent_op_pattern` in your |<a href="starting.html#vimrc">vimrc</a>|.


SHELL							<b class="vimtag">*<a name="ft-sh-indent">ft-sh-indent</a>*</b>

The amount of indent applied under various circumstances in a shell file can
be configured by setting the following keys in the |<a href="eval.html#Dictionary">Dictionary</a>|
b:sh_indent_defaults to a specific amount or to a |<a href="eval.html#Funcref">Funcref</a>| that references a
function that will return the amount desired:

b:sh_indent_options['default']	Default amount of indent.

b:sh_indent_options['continuation-line']
				Amount of indent to add to a continued line.

b:sh_indent_options['case-labels']
				Amount of indent to add for case labels.
				(not actually implemented)

b:sh_indent_options['case-statements']
				Amount of indent to add for case statements.

b:sh_indent_options['case-breaks']
				Amount of indent to add (or more likely
				remove) for case breaks.

VERILOG							<b class="vimtag">*<a name="ft-verilog-indent">ft-verilog-indent</a>*</b>

General block statements such as if, for, case, always, initial, function,
specify and begin, etc., are indented.  The module block statements (first
level blocks) are not indented by default.  you can turn on the indent with
setting a variable in the .vimrc as follows:
<code class="example"></code>
<code class="example">  let b:verilog_indent_modules = 1</code>
<code class="example"></code>
then the module blocks will be indented.  To stop this, remove the variable:
<code class="example"></code>
<code class="example">  :unlet b:verilog_indent_modules</code>
<code class="example"></code>
To set the variable only for Verilog file.  The following statements can be
used:
<code class="example"></code>
<code class="example">  au BufReadPost * if exists("b:current_syntax")</code>
<code class="example">  au BufReadPost *   if b:current_syntax == "verilog"</code>
<code class="example">  au BufReadPost *     let b:verilog_indent_modules = 1</code>
<code class="example">  au BufReadPost *   endif</code>
<code class="example">  au BufReadPost * endif</code>
<code class="example"></code>
Furthermore, setting the variable b:verilog_indent_width to change the
indenting width (default is 'shiftwidth'):
<code class="example"></code>
<code class="example">  let b:verilog_indent_width = 4</code>
<code class="example">  let b:verilog_indent_width = shiftwidth() * 2</code>
<code class="example"></code>
In addition, you can turn the verbose mode for debug issue:
<code class="example"></code>
<code class="example">  let b:verilog_indent_verbose = 1</code>
<code class="example"></code>
Make sure to do ":set cmdheight=2" first to allow the display of the message.


VHDL							<b class="vimtag">*<a name="ft-vhdl-indent">ft-vhdl-indent</a>*</b>

Alignment of generic/port mapping statements are performed by default. This
causes the following alignment example:
<code class="example"></code>
<code class="example">  ENTITY sync IS</code>
<code class="example">  PORT (</code>
<code class="example">         clk        : IN  STD_LOGIC;</code>
<code class="example">         reset_n    : IN  STD_LOGIC;</code>
<code class="example">         data_input : IN  STD_LOGIC;</code>
<code class="example">         data_out   : OUT STD_LOGIC</code>
<code class="example">       );</code>
<code class="example">  END ENTITY sync;</code>
<code class="example"></code>
To turn this off, add
<code class="example"></code>
<code class="example">  let g:vhdl_indent_genportmap = 0</code>
<code class="example"></code>
to the .vimrc file, which causes the previous alignment example to change:
<code class="example"></code>
<code class="example">  ENTITY sync IS</code>
<code class="example">  PORT (</code>
<code class="example">    clk        : IN  STD_LOGIC;</code>
<code class="example">    reset_n    : IN  STD_LOGIC;</code>
<code class="example">    data_input : IN  STD_LOGIC;</code>
<code class="example">    data_out   : OUT STD_LOGIC</code>
<code class="example">  );</code>
<code class="example">  END ENTITY sync;</code>
<code class="example"></code>
</pre><hr/><pre><code class="example"></code>
Alignment of right-hand side assignment "&lt;=" statements are performed by
default. This causes the following alignment example:
<code class="example"></code>
<code class="example">  sig_out &lt;= (bus_a(1) AND</code>
<code class="example">             (sig_b OR sig_c)) OR</code>
<code class="example">             (bus_a(0) AND sig_d);</code>
<code class="example"></code>
To turn this off, add
<code class="example"></code>
<code class="example">  let g:vhdl_indent_rhsassign = 0</code>
<code class="example"></code>
to the .vimrc file, which causes the previous alignment example to change:
<code class="example"></code>
<code class="example">  sig_out &lt;= (bus_a(1) AND</code>
<code class="example">    (sig_b OR sig_c)) OR</code>
<code class="example">    (bus_a(0) AND sig_d);</code>
<code class="example"></code>
</pre><hr/><pre><code class="example"></code>
Full-line comments (lines that begin with "--") are indented to be aligned with
the very previous line's comment, PROVIDED that a whitespace follows after
"--".

For example:
<code class="example"></code>
<code class="example">  sig_a &lt;= sig_b; -- start of a comment</code>
<code class="example">                  -- continuation of the comment</code>
<code class="example">                  -- more of the same comment</code>
<code class="example"></code>
While in Insert mode, after typing "-- " (<code class="note">note</code> the space " "), hitting <code class="keystroke">CTRL-F</code>
will align the current "-- " with the previous line's "--".

If the very previous line does not contain "--", THEN the full-line comment
will be aligned with the start of the next non-blank line that is NOT a
full-line comment.

Indenting the following code:
<code class="example"></code>
<code class="example">  sig_c &lt;= sig_d; -- comment 0</code>
<code class="example">         -- comment 1</code>
<code class="example">               -- comment 2</code>
<code class="example">    --debug_code:</code>
<code class="example">    --PROCESS(debug_in)</code>
<code class="example">         --BEGIN</code>
<code class="example">            --  FOR i IN 15 DOWNTO 0 LOOP</code>
<code class="example">             --    debug_out(8<b class="vimtag">*<a name="i+7 DOWNTO 8">i+7 DOWNTO 8</a>*</b>i) &lt;= debug_in(15-i);</code>
<code class="example">            --  END LOOP;</code>
<code class="example">     --END PROCESS debug_code;</code>
<code class="example"></code>
<code class="example">      -- comment 3</code>
<code class="example">  sig_e &lt;= sig_f; -- comment 4</code>
<code class="example">           -- comment 5</code>
<code class="example"></code>
results in:
<code class="example"></code>
<code class="example">  sig_c &lt;= sig_d; -- comment 0</code>
<code class="example">                  -- comment 1</code>
<code class="example">                  -- comment 2</code>
<code class="example">  --debug_code:</code>
<code class="example">  --PROCESS(debug_in)</code>
<code class="example">  --BEGIN</code>
<code class="example">  --  FOR i IN 15 DOWNTO 0 LOOP</code>
<code class="example">  --    debug_out(8<b class="vimtag">*<a name="i+7 DOWNTO 8">i+7 DOWNTO 8</a>*</b>i) &lt;= debug_in(15-i);</code>
<code class="example">  --  END LOOP;</code>
<code class="example">  --END PROCESS debug_code;</code>
<code class="example"></code>
<code class="example">  -- comment 3</code>
<code class="example">  sig_e &lt;= sig_f; -- comment 4</code>
<code class="example">                  -- comment 5</code>
<code class="example"></code>
Notice that "--debug_code:" does not align with "-- comment 2"
because there is no whitespace that follows after "--" in "--debug_code:".

Given the dynamic nature of indenting comments, indenting should be done TWICE.
On the first pass, code will be indented. On the second pass, full-line
comments will be indented according to the correctly indented code.


VIM							<b class="vimtag">*<a name="ft-vim-indent">ft-vim-indent</a>*</b>

For indenting Vim scripts there is one variable that specifies the amount of
indent for a continuation line, a line that starts with a backslash:
<code class="example"></code>
<code class="example">	:let g:vim_indent_cont = shiftwidth() * 3</code>
<code class="example"></code>
Three times shiftwidth is the default value.


 vim:tw=78:ts=8:noet:ft=help:norl:
</pre>
<p><i>Generated by vim2html on Wed Feb 26 03:19:42 UTC 2020</i></p>
</body>
</html>
