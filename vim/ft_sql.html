<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>VIM: ft_sql</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css"/>
</head>
<body>
<h2>FT_SQL</h2>
<pre>
<b class="vimtag">*<a name="ft_sql.txt">ft_sql.txt</a>*</b>	For Vim version 8.2.  Last change: 2019 Dec 07

by David Fishburn

This is a filetype plugin to work with SQL files.

The Structured Query Language (SQL) is a standard which specifies statements
that allow a user to interact with a relational database.  Vim includes
features for navigation, indentation and syntax highlighting.

1. Navigation					|<a href="ft_sql.html#sql-navigation">sql-navigation</a>|
    1.1 Matchit					|<a href="ft_sql.html#sql-matchit">sql-matchit</a>|
    1.2 Text Object Motions			|<a href="ft_sql.html#sql-object-motions">sql-object-motions</a>|
    1.3 Predefined Object Motions		|<a href="ft_sql.html#sql-predefined-objects">sql-predefined-objects</a>|
    1.4 Macros					|<a href="ft_sql.html#sql-macros">sql-macros</a>|
2. SQL Dialects					|<a href="ft_sql.html#sql-dialects">sql-dialects</a>|
    2.1 SQLSetType				|<a href="ft_sql.html#SQLSetType">SQLSetType</a>|
    2.2 SQLGetType				|<a href="ft_sql.html#SQLGetType">SQLGetType</a>|
    2.3 SQL Dialect Default			|<a href="ft_sql.html#sql-type-default">sql-type-default</a>|
3. Adding new SQL Dialects			|<a href="ft_sql.html#sql-adding-dialects">sql-adding-dialects</a>|
4. OMNI SQL Completion				|<a href="ft_sql.html#sql-completion">sql-completion</a>|
    4.1 Static mode				|<a href="ft_sql.html#sql-completion-static">sql-completion-static</a>|
    4.2 Dynamic mode				|<a href="ft_sql.html#sql-completion-dynamic">sql-completion-dynamic</a>|
    4.3 Tutorial				|<a href="ft_sql.html#sql-completion-tutorial">sql-completion-tutorial</a>|
	4.3.1 Complete Tables			|<a href="ft_sql.html#sql-completion-tables">sql-completion-tables</a>|
	4.3.2 Complete Columns			|<a href="ft_sql.html#sql-completion-columns">sql-completion-columns</a>|
	4.3.3 Complete Procedures		|<a href="ft_sql.html#sql-completion-procedures">sql-completion-procedures</a>|
	4.3.4 Complete Views			|<a href="ft_sql.html#sql-completion-views">sql-completion-views</a>|
    4.4 Completion Customization		|<a href="ft_sql.html#sql-completion-customization">sql-completion-customization</a>|
    4.5 SQL Maps				|<a href="ft_sql.html#sql-completion-maps">sql-completion-maps</a>|
    4.6 Using with other filetypes		|<a href="ft_sql.html#sql-completion-filetypes">sql-completion-filetypes</a>|

</pre><hr/><pre>1. Navigation					<b class="vimtag">*<a name="sql-navigation">sql-navigation</a>*</b>

The SQL ftplugin provides a number of options to assist with file
navigation.


1.1 Matchit					<b class="vimtag">*<a name="sql-matchit">sql-matchit</a>*</b>
</pre><hr/><pre>The matchit plugin (http://www.vim.org/scripts/script.php?script_id=39)
provides many additional features and can be customized for different
languages.  The matchit plugin is configured by defining a local
buffer variable, b:match_words.  Pressing the % key while on various
keywords will move the cursor to its match.  For example, if the cursor
is on an "if", pressing % will cycle between the "else", "elseif" and
"end if" keywords.

The following keywords are supported:
<code class="example">    if</code>
<code class="example">    elseif | elsif</code>
<code class="example">    else [if]</code>
<code class="example">    end if</code>
<code class="example"></code>
<code class="example">    [while condition] loop</code>
<code class="example">	leave</code>
<code class="example">	break</code>
<code class="example">	continue</code>
<code class="example">	exit</code>
<code class="example">    end loop</code>
<code class="example"></code>
<code class="example">    for</code>
<code class="example">	leave</code>
<code class="example">	break</code>
<code class="example">	continue</code>
<code class="example">	exit</code>
<code class="example">    end loop</code>
<code class="example"></code>
<code class="example">    do</code>
<code class="example">	statements</code>
<code class="example">    doend</code>
<code class="example"></code>
<code class="example">    case</code>
<code class="example">    when</code>
<code class="example">    when</code>
<code class="example">    default</code>
<code class="example">    end case</code>
<code class="example"></code>
<code class="example">    merge</code>
<code class="example">    when not matched</code>
<code class="example">    when matched</code>
<code class="example"></code>
<code class="example">    create[ or replace] procedure|<code class="badlink">function</code>|event</code>
<code class="example">    returns</code>
<code class="example"></code>
<code class="example"></code>
1.2 Text Object Motions				<b class="vimtag">*<a name="sql-object-motions">sql-object-motions</a>*</b>
</pre><hr/><pre>Vim has a number of predefined keys for working with text |<a href="motion.html#object-motions">object-motions</a>|.
This filetype plugin attempts to translate these keys to maps which make sense
for the SQL language.

The following |<a href="intro.html#Normal">Normal</a>| mode and |<a href="visual.html#Visual">Visual</a>| mode maps exist (when you edit a SQL
file):
<code class="example">    ]]		    move forward to the next 'begin'</code>
<code class="example">    [[		    move backwards to the previous 'begin'</code>
<code class="example">    ][		    move forward to the next 'end'</code>
<code class="example">    []		    move backwards to the previous 'end'</code>
<code class="example"></code>
<code class="example"></code>
1.3 Predefined Object Motions			<b class="vimtag">*<a name="sql-predefined-objects">sql-predefined-objects</a>*</b>
</pre><hr/><pre>Most relational databases support various standard features, tables, indices,
triggers and stored procedures.  Each vendor also has a variety of proprietary
objects.  The next set of maps have been created to help move between these
objects.  Depends on which database vendor you are using, the list of objects
must be configurable.  The filetype plugin attempts to define many of the
standard objects, plus many additional ones.  In order to make this as
flexible as possible, you can override the list of objects from within your
|<a href="starting.html#vimrc">vimrc</a>| with the following:
<code class="example">    let g:ftplugin_sql_objects = 'function,procedure,event,table,trigger' .</code>
<code class="example">		\ ',schema,service,publication,database,datatype,domain' .</code>
<code class="example">		\ ',index,subscription,synchronization,view,variable'</code>
<code class="example"></code>
The following |<a href="intro.html#Normal">Normal</a>| mode and |<a href="visual.html#Visual">Visual</a>| mode maps have been created which use
the above list:
<code class="example">    ]}		    move forward to the next 'create <code class="special">&lt;object name&gt;</code>'</code>
<code class="example">    [{		    move backward to the previous 'create <code class="special">&lt;object name&gt;</code>'</code>
<code class="example"></code>
Repeatedly pressing ]} will cycle through each of these create statements:
<code class="example">    create table t1 (</code>
<code class="example">	...</code>
<code class="example">    );</code>
<code class="example"></code>
<code class="example">    create procedure p1</code>
<code class="example">    begin</code>
<code class="example">	...</code>
<code class="example">    end;</code>
<code class="example"></code>
<code class="example">    create index i1 on t1 (c1);</code>
<code class="example"></code>
The default setting for g:ftplugin_sql_objects is:
<code class="example">    let g:ftplugin_sql_objects = 'function,procedure,event,' .</code>
<code class="example">		\ '\\(existing\\\\|global\\s\\+temporary\\s\\+\\)\\\<code class="special">{,1}</code>' .</code>
<code class="example">		\ 'table,trigger' .</code>
<code class="example">		\ ',schema,service,publication,database,datatype,domain' .</code>
<code class="example">		\ ',index,subscription,synchronization,view,variable'</code>
<code class="example"></code>
The above will also handle these cases:
<code class="example">    create table t1 (</code>
<code class="example">	...</code>
<code class="example">    );</code>
<code class="example">    create existing table t2 (</code>
<code class="example">	...</code>
<code class="example">    );</code>
<code class="example">    create global temporary table t3 (</code>
<code class="example">	...</code>
<code class="example">    );</code>
<code class="example"></code>
By default, the ftplugin only searches for CREATE statements.  You can also
override this via your |<a href="starting.html#vimrc">vimrc</a>| with the following:
<code class="example">    let g:ftplugin_sql_statements = 'create,alter'</code>
<code class="example"></code>
The filetype plugin defines three types of comments:
<code class="example">    1.  --</code>
<code class="example">    2.  //</code>
<code class="example">    3.  /*</code>
<code class="example">	 *</code>
<code class="example">	 */</code>
<code class="example"></code>
The following |<a href="intro.html#Normal">Normal</a>| mode and |<a href="visual.html#Visual">Visual</a>| mode maps have been created to work
with comments:
<code class="example">    ]"		    move forward to the beginning of a comment</code>
<code class="example">    ["		    move forward to the end of a comment</code>
<code class="example"></code>
<code class="example"></code>
<code class="example"></code>
1.4 Macros					   <b class="vimtag">*<a name="sql-macros">sql-macros</a>*</b>
</pre><hr/><pre>Vim's feature to find macro definitions, |<a href="options.html#'define'">'define'</a>|, is supported using this
regular expression:
<code class="example">    \c\&lt;\(VARIABLE\|<code class="badlink">DECLARE\</code>|IN\|<code class="badlink">OUT\</code>|INOUT\)\&gt;</code>
<code class="example"></code>
This addresses the following code:
<code class="example">    CREATE VARIABLE myVar1 INTEGER;</code>
<code class="example"></code>
<code class="example">    CREATE PROCEDURE sp_test(</code>
<code class="example">	IN myVar2 INTEGER,</code>
<code class="example">	OUT myVar3 CHAR(30),</code>
<code class="example">	INOUT myVar4 NUMERIC(20,0)</code>
<code class="example">    )</code>
<code class="example">    BEGIN</code>
<code class="example">	DECLARE myVar5 INTEGER;</code>
<code class="example"></code>
<code class="example">	SELECT c1, c2, c3</code>
<code class="example">	  INTO myVar2, myVar3, myVar4</code>
<code class="example">	  FROM T1</code>
<code class="example">	 WHERE c4 = myVar1;</code>
<code class="example">    END;</code>
<code class="example"></code>
Place your cursor on "myVar1" on this line:
<code class="example">	 WHERE c4 = myVar1;</code>
<code class="example">		     ^</code>
<code class="example"></code>
Press any of the following keys:
<code class="example">    [d</code>
<code class="example">    [D</code>
<code class="example">    [<code class="keystroke">CTRL-D</code></code>
<code class="example"></code>
<code class="example"></code>
</pre><hr/><pre>2. SQL Dialects					<b class="vimtag">*<a name="sql-dialects">sql-dialects</a>*</b> <b class="vimtag">*<a name="sql-types">sql-types</a>*</b>
						<b class="vimtag">*<a name="sybase">sybase</a>*</b> <b class="vimtag">*<a name="TSQL">TSQL</a>*</b> <b class="vimtag">*<a name="Transact-SQL">Transact-SQL</a>*</b>
						<b class="vimtag">*<a name="sqlanywhere">sqlanywhere</a>*</b>
						<b class="vimtag">*<a name="oracle">oracle</a>*</b> <b class="vimtag">*<a name="plsql">plsql</a>*</b> <b class="vimtag">*<a name="sqlj">sqlj</a>*</b>
						<b class="vimtag">*<a name="sqlserver">sqlserver</a>*</b>
						<b class="vimtag">*<a name="mysql">mysql</a>*</b> <b class="vimtag">*<a name="postgresql">postgresql</a>*</b> <b class="vimtag">*<a name="psql">psql</a>*</b>
						<b class="vimtag">*<a name="informix">informix</a>*</b>

All relational databases support SQL.  There is a portion of SQL that is
portable across vendors (ex. CREATE TABLE, CREATE INDEX), but there is a
great deal of vendor specific extensions to SQL.  Oracle supports the
"CREATE OR REPLACE" syntax, column defaults specified in the CREATE TABLE
statement and the procedural language (for stored procedures and triggers).

The default Vim distribution ships with syntax highlighting based on Oracle's
PL/SQL.  The default SQL indent script works for Oracle and SQL Anywhere.
The default filetype plugin works for all vendors and should remain vendor
neutral, but extendable.

Vim currently has support for a variety of different vendors, currently this
is via syntax scripts. Unfortunately, to flip between different syntax rules
you must either create:
    1.  New filetypes
    2.  Custom autocmds
    3.  Manual steps / commands

The majority of people work with only one vendor's database product, it would
be nice to specify a default in your |<a href="starting.html#vimrc">vimrc</a>|.


2.1 SQLSetType					<b class="vimtag">*<a name="sqlsettype">sqlsettype</a>*</b> <b class="vimtag">*<a name="SQLSetType">SQLSetType</a>*</b>
</pre><hr/><pre>For the people that work with many different databases, it is nice to be
able to flip between the various vendors rules (indent, syntax) on a per
buffer basis, at any time.  The ftplugin/sql.vim file defines this function:
<code class="example">    SQLSetType</code>
<code class="example"></code>
Executing this function without any parameters will set the indent and syntax
scripts back to their defaults, see |<a href="ft_sql.html#sql-type-default">sql-type-default</a>|.  If you have turned
off Vi's compatibility mode, |<a href="options.html#'compatible'">'compatible'</a>|, you can use the <code class="special">&lt;Tab&gt;</code> key to
complete the optional parameter.

After typing the function name and a space, you can use the completion to
supply a parameter.  The function takes the name of the Vim script you want to
source.  Using the |<a href="cmdline.html#cmdline-completion">cmdline-completion</a>| feature, the SQLSetType function will
search the |<a href="options.html#'runtimepath'">'runtimepath'</a>| for all Vim scripts with a name containing 'sql'.
This takes the guess work out of the spelling of the names.  The following are
examples:
<code class="example">    :SQLSetType</code>
<code class="example">    :SQLSetType sqloracle</code>
<code class="example">    :SQLSetType sqlanywhere</code>
<code class="example">    :SQLSetType sqlinformix</code>
<code class="example">    :SQLSetType mysql</code>
<code class="example"></code>
The easiest approach is to the use <code class="special">&lt;Tab&gt;</code> character which will first complete
the command name (SQLSetType), after a space and another <code class="special">&lt;Tab&gt;</code>, display a list
of available Vim script names:
<code class="example">    :SQL<code class="special">&lt;Tab&gt;</code><code class="special">&lt;space&gt;</code><code class="special">&lt;Tab&gt;</code></code>
<code class="example"></code>
<code class="example"></code>
2.2 SQLGetType					<b class="vimtag">*<a name="sqlgettype">sqlgettype</a>*</b> <b class="vimtag">*<a name="SQLGetType">SQLGetType</a>*</b>
</pre><hr/><pre>At anytime you can determine which SQL dialect you are using by calling the
SQLGetType command.  The ftplugin/sql.vim file defines this function:
<code class="example">    SQLGetType</code>
<code class="example"></code>
This will echo:
<code class="example">    Current SQL dialect in use:sqlanywhere</code>
<code class="example"></code>
<code class="example"></code>
2.3 SQL Dialect Default				<b class="vimtag">*<a name="sql-type-default">sql-type-default</a>*</b>
</pre><hr/><pre>As mentioned earlier, the default syntax rules for Vim is based on Oracle
(PL/SQL).  You can override this default by placing one of the following in
your |<a href="starting.html#vimrc">vimrc</a>|:
<code class="example">    let g:sql_type_default = 'sqlanywhere'</code>
<code class="example">    let g:sql_type_default = 'sqlinformix'</code>
<code class="example">    let g:sql_type_default = 'mysql'</code>
<code class="example"></code>
If you added the following to your |<a href="starting.html#vimrc">vimrc</a>|:
<code class="example">    let g:sql_type_default = 'sqlinformix'</code>
<code class="example"></code>
The next time edit a SQL file the following scripts will be automatically
loaded by Vim:
<code class="example">    ftplugin/sql.vim</code>
<code class="example">    syntax/sqlinformix.vim</code>
<code class="example">    indent/sql.vim</code>

Notice indent/sqlinformix.sql was not loaded.  There is no indent file
for Informix, Vim loads the default files if the specified files does not
exist.


</pre><hr/><pre>3. Adding new SQL Dialects			<b class="vimtag">*<a name="sql-adding-dialects">sql-adding-dialects</a>*</b>

If you begin working with a SQL dialect which does not have any customizations
available with the default Vim distribution you can check http://www.vim.org
to see if any customization currently exist.  If not, you can begin by cloning
an existing script.  Read |<a href="filetype.html#filetype-plugins">filetype-plugins</a>| for more details.

To help identify these scripts, try to create the files with a "sql" prefix.
If you decide you wish to create customizations for the SQLite database, you
can create any of the following:
<code class="example">    Unix</code>
<code class="example">	~/.vim/syntax/sqlite.vim</code>
<code class="example">	~/.vim/indent/sqlite.vim</code>
<code class="example">    Windows</code>
<code class="example">	$VIM/vimfiles/syntax/sqlite.vim</code>
<code class="example">	$VIM/vimfiles/indent/sqlite.vim</code>
<code class="example"></code>
No changes are necessary to the SQLSetType function.  It will automatically
pickup the new SQL files and load them when you issue the SQLSetType command.


</pre><hr/><pre>4. OMNI SQL Completion				<b class="vimtag">*<a name="sql-completion">sql-completion</a>*</b>
						<b class="vimtag">*<a name="omni-sql-completion">omni-sql-completion</a>*</b>

Vim 7 includes a code completion interface and functions which allows plugin
developers to build in code completion for any language.  Vim 7 includes
code completion for the SQL language.

There are two modes to the SQL completion plugin, static and dynamic.  The
static mode populates the popups with the data generated from current syntax
highlight rules.  The dynamic mode populates the popups with data retrieved
directly from a database.  This includes, table lists, column lists,
procedures names and more.

4.1 Static Mode					<b class="vimtag">*<a name="sql-completion-static">sql-completion-static</a>*</b>
</pre><hr/><pre>The static popups created contain items defined by the active syntax rules
while editing a file with a filetype of SQL.  The plugin defines (by default)
various maps to help the user refine the list of items to be displayed.
The defaults static maps are:
<code class="example">    imap <code class="special">&lt;buffer&gt;</code> <code class="special">&lt;C-C&gt;</code>a <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-O&gt;</code>:call sqlcomplete#Map('syntax')<code class="special">&lt;CR&gt;</code><code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code></code>
<code class="example">    imap <code class="special">&lt;buffer&gt;</code> <code class="special">&lt;C-C&gt;</code>k <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-O&gt;</code>:call sqlcomplete#Map('sqlKeyword')<code class="special">&lt;CR&gt;</code><code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code></code>
<code class="example">    imap <code class="special">&lt;buffer&gt;</code> <code class="special">&lt;C-C&gt;</code>f <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-O&gt;</code>:call sqlcomplete#Map('sqlFunction')<code class="special">&lt;CR&gt;</code><code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code></code>
<code class="example">    imap <code class="special">&lt;buffer&gt;</code> <code class="special">&lt;C-C&gt;</code>o <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-O&gt;</code>:call sqlcomplete#Map('sqlOption')<code class="special">&lt;CR&gt;</code><code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code></code>
<code class="example">    imap <code class="special">&lt;buffer&gt;</code> <code class="special">&lt;C-C&gt;</code>T <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-O&gt;</code>:call sqlcomplete#Map('sqlType')<code class="special">&lt;CR&gt;</code><code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code></code>
<code class="example">    imap <code class="special">&lt;buffer&gt;</code> <code class="special">&lt;C-C&gt;</code>s <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-O&gt;</code>:call sqlcomplete#Map('sqlStatement')<code class="special">&lt;CR&gt;</code><code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code></code>
<code class="example"></code>
The use of "<code class="special">&lt;C-C&gt;</code>" can be user chosen by using the following in your |<a href="starting.html#.vimrc">.vimrc</a>|
as it may not work properly on all platforms:
<code class="example">    let g:ftplugin_sql_omni_key = '<code class="special">&lt;C-C&gt;</code>'</code>

The static maps (which are based on the syntax highlight groups) follow this
format:
<code class="example">    imap <code class="special">&lt;buffer&gt;</code> <code class="special">&lt;C-C&gt;</code>k <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-O&gt;</code>:call sqlcomplete#Map('sqlKeyword')<code class="special">&lt;CR&gt;</code><code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code></code>
<code class="example">    imap <code class="special">&lt;buffer&gt;</code> <code class="special">&lt;C-C&gt;</code>k <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-O&gt;</code>:call sqlcomplete#Map('sqlKeyword\w*')<code class="special">&lt;CR&gt;</code><code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code></code>
<code class="example"></code>
This command breaks down as:
<code class="example">    imap		   - Create an insert map</code>
<code class="example">    <code class="special">&lt;buffer&gt;</code>		   - Only for this buffer</code>
<code class="example">    <code class="special">&lt;C-C&gt;</code>k		   - Your choice of key map</code>
<code class="example">    <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-O&gt;</code>		   - Execute one command, return to Insert mode</code>
<code class="example">    :call sqlcomplete#Map( - Allows the SQL completion plugin to perform some</code>
<code class="example">			     housekeeping functions to allow it to be used in</code>
<code class="example">			     conjunction with other completion plugins.</code>
<code class="example">			     Indicate which item you want the SQL completion</code>
<code class="example">			     plugin to complete.</code>
<code class="example">			     In this case we are asking the plugin to display</code>
<code class="example">			     items from the syntax highlight group</code>
<code class="example">			     'sqlKeyword'.</code>
<code class="example">			     You can view a list of highlight group names to</code>
<code class="example">			     choose from by executing the</code>
<code class="example">				 :syntax list</code>
<code class="example">			     command while editing a SQL file.</code>
<code class="example">    'sqlKeyword'	   - Display the items for the sqlKeyword highlight</code>
<code class="example">			     group</code>
<code class="example">    'sqlKeyword\w*'	   - A second option available with Vim 7.4 which</code>
<code class="example">                             uses a regular expression to determine which</code>
<code class="example">			     syntax groups to use</code>
<code class="example">    )<code class="special">&lt;CR&gt;</code>		   - Execute the :let command</code>
<code class="example">    <code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code>		   - Trigger the standard omni completion key stroke.</code>
<code class="example">			     Passing in 'sqlKeyword' instructs the SQL</code>
<code class="example">			     completion plugin to populate the popup with</code>
<code class="example">			     items from the sqlKeyword highlight group.  The</code>
<code class="example">			     plugin will also cache this result until Vim is</code>
<code class="example">			     restarted.  The syntax list is retrieved using</code>
<code class="example">			     the syntaxcomplete plugin.</code>
<code class="example"></code>
Using the 'syntax' keyword is a special case.  This instructs the
syntaxcomplete plugin to retrieve all syntax items.  So this will effectively
work for any of Vim's SQL syntax files.  At the time of writing this includes
10 different syntax files for the different dialects of SQL (see section 3
above, |<a href="ft_sql.html#sql-dialects">sql-dialects</a>|).

Here are some examples of the entries which are pulled from the syntax files:
<code class="example">     All</code>
<code class="example">	 - Contains the contents of all syntax highlight groups</code>
<code class="example">     Statements</code>
<code class="example">	 - Select, Insert, Update, Delete, Create, Alter, ...</code>
<code class="example">     Functions</code>
<code class="example">	 - Min, Max, Trim, Round, Date, ...</code>
<code class="example">     Keywords</code>
<code class="example">	 - Index, Database, Having, Group, With</code>
<code class="example">     Options</code>
<code class="example">	 - Isolation_level, On_error, Qualify_owners, Fire_triggers, ...</code>
<code class="example">     Types</code>
<code class="example">	 - Integer, Char, Varchar, Date, DateTime, Timestamp, ...</code>
<code class="example"></code>
<code class="example"></code>
4.2 Dynamic Mode				<b class="vimtag">*<a name="sql-completion-dynamic">sql-completion-dynamic</a>*</b>
</pre><hr/><pre>Dynamic mode populates the popups with data directly from a database.  In
order for the dynamic feature to be enabled you must have the dbext.vim
plugin installed, (http://vim.sourceforge.net/script.php?script_id=356).

Dynamic mode is used by several features of the SQL completion plugin.
After installing the dbext plugin see the dbext-tutorial for additional
configuration and usage.  The dbext plugin allows the SQL completion plugin
to display a list of tables, procedures, views and columns.
<code class="example">     Table List</code>
<code class="example">	 - All tables for all schema owners</code>
<code class="example">     Procedure List</code>
<code class="example">	 - All stored procedures for all schema owners</code>
<code class="example">     View List</code>
<code class="example">	 - All stored procedures for all schema owners</code>
<code class="example">     Column List</code>
<code class="example">	 - For the selected table, the columns that are part of the table</code>
<code class="example"></code>
To enable the popup, while in INSERT mode, use the following key combinations
for each group (where <code class="special">&lt;C-C&gt;</code> means hold the CTRL key down while pressing
the space bar):
     Table List		   - <code class="special">&lt;C-C&gt;</code>t
			   - <code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code> (the default map assumes tables)
     Stored Procedure List - <code class="special">&lt;C-C&gt;</code>p
     View List		   - <code class="special">&lt;C-C&gt;</code>v
     Column List	   - <code class="special">&lt;C-C&gt;</code>c

     Drilling In / Out     - When viewing a popup window displaying the list
			     of tables, you can press <code class="special">&lt;Right&gt;</code>, this will
			     replace the table currently highlighted with
			     the column list for that table.
			   - When viewing a popup window displaying the list
			     of columns, you can press <code class="special">&lt;Left&gt;</code>, this will
			     replace the column list with the list of tables.
			   - This allows you to quickly drill down into a
			     table to view its columns and back again.
			   - <code class="special">&lt;Right&gt;</code> and <code class="special">&lt;Left&gt;</code> can be also be chosen via
			     your |<a href="starting.html#.vimrc">.vimrc</a>|
<code class="example">                                let g:ftplugin_sql_omni_key_right = '<code class="special">&lt;Right&gt;</code>'</code>
<code class="example">                                let g:ftplugin_sql_omni_key_left  = '<code class="special">&lt;Left&gt;</code>'</code>
<code class="example"></code>
The SQL completion plugin caches various lists that are displayed in
the popup window.  This makes the re-displaying of these lists very
fast.  If new tables or columns are added to the database it may become
necessary to clear the plugins cache.  The default map for this is:
<code class="example">    imap <code class="special">&lt;buffer&gt;</code> <code class="special">&lt;C-C&gt;</code>R <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-O&gt;</code>:call sqlcomplete#Map('ResetCache')<code class="special">&lt;CR&gt;</code><code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code></code>
<code class="example"></code>
<code class="example"></code>
4.3 SQL Tutorial				<b class="vimtag">*<a name="sql-completion-tutorial">sql-completion-tutorial</a>*</b>
</pre><hr/><pre>
This tutorial is designed to take you through the common features of the SQL
completion plugin so that:
<code class="example">     a) You gain familiarity with the plugin</code>
<code class="example">     b) You are introduced to some of the more common features</code>
<code class="example">     c) Show how to customize it to your preferences</code>
<code class="example">     d) Demonstrate "Best of Use" of the plugin (easiest way to configure).</code>
<code class="example"></code>
First, create a new buffer:
<code class="example">     :e tutorial.sql</code>
<code class="example"></code>
<code class="example"></code>
Static features
</pre><hr/><pre>To take you through the various lists, simply enter insert mode, hit:
    <code class="special">&lt;C-C&gt;</code>s   (show SQL statements)
At this point, you can page down through the list until you find "select".
If you are familiar with the item you are looking for, for example you know
the statement begins with the letter "s".  You can type ahead (without the
quotes) "se" then press:
    <code class="special">&lt;C-Space&gt;</code>t
Assuming "select" is highlighted in the popup list press <code class="special">&lt;Enter&gt;</code> to choose
the entry.  Now type:
    * fr<code class="special">&lt;C-C&gt;</code>a (show all syntax items)
choose "from" from the popup list.

When writing stored procedures using the "type" list is useful.  It contains
a list of all the database supported types.  This may or may not be true
depending on the syntax file you are using.  The SQL Anywhere syntax file
(sqlanywhere.vim) has support for this:
<code class="example">     BEGIN</code>
<code class="example">	DECLARE customer_id <code class="special">&lt;C-C&gt;</code>T &lt;-- Choose a type from the list</code>
<code class="example"></code>
<code class="example"></code>
Dynamic features
</pre><hr/><pre>To take advantage of the dynamic features you must first install the
dbext.vim plugin (http://vim.sourceforge.net/script.php?script_id=356).  It
also comes with a tutorial.  From the SQL completion plugin's perspective,
the main feature dbext provides is a connection to a database.  dbext
connection profiles are the most efficient mechanism to define connection
information.  Once connections have been setup, the SQL completion plugin
uses the features of dbext in the background to populate the popups.

What follows assumes dbext.vim has been correctly configured, a simple test
is to run the command, :DBListTable.  If a list of tables is shown, you know
dbext.vim is working as expected.  If not, please consult the dbext.txt
documentation.

Assuming you have followed the dbext-tutorial you can press <code class="special">&lt;C-C&gt;</code>t to
display a list of tables.  There is a delay while dbext is creating the table
list.  After the list is displayed press <code class="special">&lt;C-W&gt;</code>.  This will remove both the
popup window and the table name already chosen when the list became active.
<code class="example"></code>
<code class="example"> 4.3.1 Table Completion:			<b class="vimtag">*<a name="sql-completion-tables">sql-completion-tables</a>*</b></code>
<code class="example"></code>
Press <code class="special">&lt;C-C&gt;</code>t to display a list of tables from within the database you
have connected via the dbext plugin.
<code class="note">NOTE:</code> All of the SQL completion popups support typing a prefix before pressing
the key map.  This will limit the contents of the popup window to just items
beginning with those characters.
<code class="example"></code>
<code class="example"> 4.3.2 Column Completion:			<b class="vimtag">*<a name="sql-completion-columns">sql-completion-columns</a>*</b></code>
<code class="example"></code>
The SQL completion plugin can also display a list of columns for particular
tables.  The column completion is trigger via <code class="special">&lt;C-C&gt;</code>c.

<code class="note">NOTE:</code> The following example uses <code class="special">&lt;Right&gt;</code> to trigger a column list while
      the popup window is active.

Example of using column completion:
     - Press <code class="special">&lt;C-C&gt;</code>t again to display the list of tables.
     - When the list is displayed in the completion window, press <code class="special">&lt;Right&gt;</code>,
       this will replace the list of tables, with a list of columns for the
       table highlighted (after the same short delay).
     - If you press <code class="special">&lt;Left&gt;</code>, this will again replace the column list with the
       list of tables.  This allows you to drill into tables and column lists
       very quickly.
     - Press <code class="special">&lt;Right&gt;</code> again while the same table is highlighted.  You will
       notice there is no delay since the column list has been cached.  If you
       change the schema of a cached table you can press <code class="special">&lt;C-C&gt;</code>R, which
       clears the SQL completion cache.
     - <code class="note">NOTE:</code> <code class="special">&lt;Right&gt;</code> and <code class="special">&lt;Left&gt;</code> have been designed to work while the
       completion window is active.  If the completion popup window is
       not active, a normal <code class="special">&lt;Right&gt;</code> or <code class="special">&lt;Left&gt;</code> will be executed.

Let's look at how we can build a SQL statement dynamically.  A select statement
requires a list of columns.  There are two ways to build a column list using
the SQL completion plugin.
<code class="example">    One column at a time:</code>
       1. After typing SELECT press <code class="special">&lt;C-C&gt;</code>t to display a list of tables.
	2. Choose a table from the list.
	3. Press <code class="special">&lt;Right&gt;</code> to display a list of columns.
	4. Choose the column from the list and press enter.
	5. Enter a "," and press <code class="special">&lt;C-C&gt;</code>c.  Generating a column list
	   generally requires having the cursor on a table name.  The plugin
	   uses this name to determine what table to retrieve the column list.
	   In this step, since we are pressing <code class="special">&lt;C-C&gt;</code>c without the cursor
	   on a table name the column list displayed will be for the previous
	   table.  Choose a different column and move on.
	6. Repeat step 5 as often as necessary.
<code class="example">    All columns for a table:</code>
	1. After typing SELECT press <code class="special">&lt;C-C&gt;</code>t to display a list of tables.
	2. Highlight the table you need the column list for.
	3. Press <code class="special">&lt;Enter&gt;</code> to choose the table from the list.
	4. Press <code class="special">&lt;C-C&gt;</code>l to request a comma separated list of all columns
	   for this table.
	5. Based on the table name chosen in step 3, the plugin attempts to
	   decide on a reasonable table alias.	You are then prompted to
	   either accept of change the alias.  Press OK.
	6. The table name is replaced with the column list of the table is
	   replaced with the comma separate list of columns with the alias
	   prepended to each of the columns.
	7. Step 3 and 4 can be replaced by pressing <code class="special">&lt;C-C&gt;</code>L, which has
	   a <code class="special">&lt;C-Y&gt;</code> embedded in the map to choose the currently highlighted
	   table in the list.

There is a special provision when writing select statements.  Consider the
following statement:
<code class="example">     select *</code>
<code class="example">       from customer c,</code>
<code class="example">	    contact cn,</code>
<code class="example">	    department as dp,</code>
<code class="example">	    employee e,</code>
<code class="example">	    site_options so</code>
<code class="example">      where c.</code>
<code class="example"></code>
In INSERT mode after typing the final "c." which is an alias for the
"customer" table, you can press either <code class="special">&lt;C-C&gt;</code>c or <code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code>.  This will
popup a list of columns for the customer table.  It does this by looking back
to the beginning of the select statement and finding a list of the tables
specified in the FROM clause.  In this case it <code class="note">note</code>s that in the string
"customer c", "c" is an alias for the customer table.  The optional "AS"
keyword is also supported, "customer AS c".
<code class="example"></code>
<code class="example"></code>
<code class="example"> 4.3.3 Procedure Completion:			<b class="vimtag">*<a name="sql-completion-procedures">sql-completion-procedures</a>*</b></code>
<code class="example"></code>
Similar to the table list, <code class="special">&lt;C-C&gt;</code>p, will display a list of stored
procedures stored within the database.
<code class="example"></code>
<code class="example"> 4.3.4 View Completion:				<b class="vimtag">*<a name="sql-completion-views">sql-completion-views</a>*</b></code>
<code class="example"></code>
Similar to the table list, <code class="special">&lt;C-C&gt;</code>v, will display a list of views in the
database.


4.4 Completion Customization			<b class="vimtag">*<a name="sql-completion-customization">sql-completion-customization</a>*</b>
</pre><hr/><pre>
The SQL completion plugin can be customized through various options set in
your |<a href="starting.html#vimrc">vimrc</a>|:
<code class="example">    omni_sql_no_default_maps</code>
       - Default: This variable is not defined
	- If this variable is defined, no maps are created for OMNI
	  completion.  See |<a href="ft_sql.html#sql-completion-maps">sql-completion-maps</a>| for further discussion.

<code class="example">    omni_sql_use_tbl_alias</code>
	- Default: a
	- This setting is only used when generating a comma separated
	  column list.	By default the map is <code class="special">&lt;C-C&gt;</code>l.  When generating
	  a column list, an alias can be prepended to the beginning of each
	  column, for example:	e.emp_id, e.emp_name.  This option has three
	  settings:
<code class="example">		n - do not use an alias</code>
<code class="example">		d - use the default (calculated) alias</code>
<code class="example">		a - ask to confirm the alias name</code>

	  An alias is determined following a few rules:
	       1.  If the table name has an '_', then use it as a separator:
<code class="example">		   MY_TABLE_NAME --&gt; MTN</code>
<code class="example">		   my_table_name --&gt; mtn</code>
<code class="example">		   My_table_NAME --&gt; MtN</code>
	       2.  If the table name does NOT contain an '_', but DOES use
		   mixed case then the case is used as a separator:
<code class="example">		   MyTableName --&gt; MTN</code>
	       3.  If the table name does NOT contain an '_', and does NOT
		   use mixed case then the first letter of the table is used:
<code class="example">		   mytablename --&gt; m</code>
<code class="example">		   MYTABLENAME --&gt; M</code>
<code class="example"></code>
<code class="example">    omni_sql_ignorecase</code>
	- Default: Current setting for 'ignorecase'
	- Valid settings are 0 or 1.
	- When entering a few letters before initiating completion, the list
	  will be filtered to display only the entries which begin with the
	  list of characters.  When this option is set to 0, the list will be
	  filtered using case sensitivity.
<code class="example"></code>
<code class="example">    omni_sql_include_owner</code>
	- Default: 0, unless dbext.vim 3.00 has been installed
	- Valid settings are 0 or 1.
	- When completing tables, procedure or views and using dbext.vim 3.00
	  or higher the list of objects will also include the owner name.
	  When completing these objects and omni_sql_include_owner is enabled
	  the owner name will be replaced.
<code class="example"></code>
<code class="example">    omni_sql_precache_syntax_groups</code>
	- Default:
	  ['syntax','sqlKeyword','sqlFunction','sqlOption','sqlType','sqlStatement']
	- sqlcomplete can be used in conjunction with other completion
	  plugins.  This is outlined at |<a href="ft_sql.html#sql-completion-filetypes">sql-completion-filetypes</a>|.  When the
	  filetype is changed temporarily to SQL, the sqlcompletion plugin
	  will cache the syntax groups listed in the List specified in this
	  option.

<code class="example"></code>
4.5 SQL Maps					<b class="vimtag">*<a name="sql-completion-maps">sql-completion-maps</a>*</b>
</pre><hr/><pre>
The default SQL maps have been described in other sections of this document in
greater detail.  Here is a list of the maps with a brief description of each.

Static Maps
</pre><hr/><pre>These are maps which use populate the completion list using Vim's syntax
highlighting rules.
<code class="example">    <code class="special">&lt;C-C&gt;</code>a</code>
&lt;       - Displays all SQL syntax items.
<code class="example">    <code class="special">&lt;C-C&gt;</code>k</code>
&lt;       - Displays all SQL syntax items defined as 'sqlKeyword'.
<code class="example">    <code class="special">&lt;C-C&gt;</code>f</code>
&lt;       - Displays all SQL syntax items defined as 'sqlFunction.
<code class="example">    <code class="special">&lt;C-C&gt;</code>o</code>
&lt;       - Displays all SQL syntax items defined as 'sqlOption'.
<code class="example">    <code class="special">&lt;C-C&gt;</code>T</code>
&lt;       - Displays all SQL syntax items defined as 'sqlType'.
<code class="example">    <code class="special">&lt;C-C&gt;</code>s</code>
&lt;       - Displays all SQL syntax items defined as 'sqlStatement'.
<code class="example"></code>
Dynamic Maps
</pre><hr/><pre>These are maps which use populate the completion list using the dbext.vim
plugin.
<code class="example">    <code class="special">&lt;C-C&gt;</code>t</code>
&lt;       - Displays a list of tables.
<code class="example">    <code class="special">&lt;C-C&gt;</code>p</code>
&lt;       - Displays a list of procedures.
<code class="example">    <code class="special">&lt;C-C&gt;</code>v</code>
&lt;       - Displays a list of views.
<code class="example">    <code class="special">&lt;C-C&gt;</code>c</code>
&lt;       - Displays a list of columns for a specific table.
<code class="example">    <code class="special">&lt;C-C&gt;</code>l</code>
&lt;       - Displays a comma separated list of columns for a specific table.
<code class="example">    <code class="special">&lt;C-C&gt;</code>L</code>
       - Displays a comma separated list of columns for a specific table.
	  This should only be used when the completion window is active.
<code class="example">    <code class="special">&lt;Right&gt;</code></code>
	- Displays a list of columns for the table currently highlighted in
	  the completion window.  <code class="special">&lt;Right&gt;</code> is not recognized on most Unix
	  systems, so this maps is only created on the Windows platform.
	  If you would like the same feature on Unix, choose a different key
	  and make the same map in your vimrc.
<code class="example">    <code class="special">&lt;Left&gt;</code></code>
	- Displays the list of tables.
	  <code class="special">&lt;Left&gt;</code> is not recognized on most Unix systems, so this maps is
	  only created on the Windows platform.  If you would like the same
	  feature on Unix, choose a different key and make the same map in
	  your vimrc.
<code class="example">    <code class="special">&lt;C-C&gt;</code>R</code>
	- This maps removes all cached items and forces the SQL completion
	  to regenerate the list of items.

Customizing Maps
</pre><hr/><pre>You can create as many additional key maps as you like.  Generally, the maps
will be specifying different syntax highlight groups.

If you do not wish the default maps created or the key choices do not work on
your platform (often a case on *nix) you define the following variable in
your |<a href="starting.html#vimrc">vimrc</a>|:
<code class="example">    let g:omni_sql_no_default_maps = 1</code>
<code class="example"></code>
Do no edit ftplugin/sql.vim directly!  If you change this file your changes
will be over written on future updates.  Vim has a special directory structure
which allows you to make customizations without changing the files that are
included with the Vim distribution.  If you wish to customize the maps
create an after/ftplugin/sql.vim (see |<a href="options.html#after-directory">after-directory</a>|) and place the same
maps from the ftplugin/sql.vim in it using your own key strokes.  <code class="special">&lt;C-C&gt;</code> was
chosen since it will work on both Windows and *nix platforms.  On the windows
platform you can also use <code class="special">&lt;C-Space&gt;</code> or ALT keys.


4.6 Using with other filetypes			<b class="vimtag">*<a name="sql-completion-filetypes">sql-completion-filetypes</a>*</b>
</pre><hr/><pre>
Many times SQL can be used with different filetypes.  For example Perl, Java,
PHP, Javascript can all interact with a database.  Often you need both the SQL
completion and the completion capabilities for the current language you are
editing.

This can be enabled easily with the following steps (assuming a Perl file):
<code class="example">    1.  :e test.pl</code>
<code class="example">    2.  :set filetype=sql</code>
<code class="example">    3.  :set ft=perl</code>
<code class="example"></code>
Step 1
</pre><hr/><pre>Begins by editing a Perl file.  Vim automatically sets the filetype to
"perl".  By default, Vim runs the appropriate filetype file
ftplugin/perl.vim.  If you are using the syntax completion plugin by following
the directions at |<a href="insert.html#ft-syntax-omni">ft-syntax-omni</a>| then the |<a href="options.html#'omnifunc'">'omnifunc'</a>| option has been set to
"syntax#Complete".  Pressing <code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code> will display the omni popup containing
the syntax items for Perl.

Step 2
</pre><hr/><pre>Manually setting the filetype to 'sql' will also fire the appropriate filetype
files ftplugin/sql.vim.  This file will define a number of buffer specific
maps for SQL completion, see |<a href="ft_sql.html#sql-completion-maps">sql-completion-maps</a>|.  Now these maps have
been created and the SQL completion plugin has been initialized.  All SQL
syntax items have been cached in preparation.  The SQL filetype script detects
we are attempting to use two different completion plugins.  Since the SQL maps
begin with <code class="special">&lt;C-C&gt;</code>, the maps will toggle the |<a href="options.html#'omnifunc'">'omnifunc'</a>| when in use.  So you
can use <code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-O&gt;</code> to continue using the completion for Perl (using the syntax
completion plugin) and <code class="special">&lt;C-C&gt;</code> to use the SQL completion features.

Step 3
</pre><hr/><pre>Setting the filetype back to Perl sets all the usual "perl" related items back
as they were.


vim:tw=78:ts=8:noet:ft=help:norl:
</pre>
<p><i>Generated by vim2html on Wed Feb 26 03:19:42 UTC 2020</i></p>
</body>
</html>
